SQL> SET VERIFY ON
SQL> SET FEEDBACK ON
SQL> SET DEFINE ON
SQL> CLEAR SCREEN
SQL> set serveroutput on
SQL> 
SQL> COLUMN date_time NEW_VAL filename noprint;
SQL> SELECT to_char(systimestamp,'yyyy-mm-dd_hh24-mi-ssxff') date_time FROM DUAL;




1 row selected. 

SQL> spool "migrationRepo_&filename..log"
SQL> 
SQL> -- Password file execution
SQL> -- @passworddefinition.sql
SQL> 
SQL> PROMPT Dropping Role ROLE_migrationRepo ...
Dropping Role ROLE_migrationRepo ...
SQL> DROP ROLE ROLE_migrationRepo ;

Error starting at line : 16 File @ D:\univer\!МСХОАД\migrate\migrationRepo\generated\2025-02-18_10-02-17\master.sql
In command -
DROP ROLE ROLE_migrationRepo
Error report -
ORA-01919: роль 'ROLE_MIGRATIONREPO' не существует

https://docs.oracle.com/error-help/db/ora-01919/01919. 00000 -  "Role '%s' does not exist."
*Document: YES
*Cause:    A role with the specified name did not exist.
*Action:   Verify that the role name is correct and retry the operation.
*Params:   1) role_name
SQL> PROMPT Creating Role ROLE_migrationRepo ...
Creating Role ROLE_migrationRepo ...
SQL> CREATE ROLE ROLE_migrationRepo ;

Error starting at line : 18 File @ D:\univer\!МСХОАД\migrate\migrationRepo\generated\2025-02-18_10-02-17\master.sql
In command -
CREATE ROLE ROLE_migrationRepo
Error report -
ORA-65096: недопустимое имя общего пользователя или имя роли

https://docs.oracle.com/error-help/db/ora-65096/65096. 00000 -  "common user or role name must start with prefix %s"
*Cause:    An attempt is being made to create a common user or role without
           the correct prefix as specified in the COMMON_USER_PREFIX
           parameter.
*Action:   Specify a valid common user or role name with the correct prefix.
*Params:   1) common_user_prefix
           parameter.
SQL> 
SQL> -- PROMPT Drop lab10 user
SQL> -- drop user lab10 cascade;
SQL> 
SQL> PROMPT Create user lab10
Create user lab10
SQL> CREATE USER lab10 IDENTIFIED BY &&lab10_password PASSWORD EXPIRE ACCOUNT LOCK /* DEFAULT TABLESPACE USERS  TEMPORARY TABLESPACE TEMP */;
old:CREATE USER lab10 IDENTIFIED BY &&lab10_password PASSWORD EXPIRE ACCOUNT LOCK /* DEFAULT TABLESPACE USERS  TEMPORARY TABLESPACE TEMP */
new:CREATE USER lab10 IDENTIFIED BY "l2O0IhiTE$TYrr5a" PASSWORD EXPIRE ACCOUNT LOCK /* DEFAULT TABLESPACE USERS  TEMPORARY TABLESPACE TEMP */

Error starting at line : 24 File @ D:\univer\!МСХОАД\migrate\migrationRepo\generated\2025-02-18_10-02-17\master.sql
In command -
CREATE USER lab10 IDENTIFIED BY &&lab10_password PASSWORD EXPIRE ACCOUNT LOCK /* DEFAULT TABLESPACE USERS  TEMPORARY TABLESPACE TEMP */
Error report -
ORA-65096: недопустимое имя общего пользователя или имя роли

https://docs.oracle.com/error-help/db/ora-65096/65096. 00000 -  "common user or role name must start with prefix %s"
*Cause:    An attempt is being made to create a common user or role without
           the correct prefix as specified in the COMMON_USER_PREFIX
           parameter.
*Action:   Specify a valid common user or role name with the correct prefix.
*Params:   1) common_user_prefix
           parameter.
SQL> GRANT CREATE SESSION, RESOURCE, CREATE VIEW, CREATE MATERIALIZED VIEW, CREATE SYNONYM, UNLIMITED TABLESPACE TO lab10;

Error starting at line : 25 File @ D:\univer\!МСХОАД\migrate\migrationRepo\generated\2025-02-18_10-02-17\master.sql
In command -
GRANT CREATE SESSION, RESOURCE, CREATE VIEW, CREATE MATERIALIZED VIEW, CREATE SYNONYM, UNLIMITED TABLESPACE TO lab10
Error report -
ORA-01917: пользователь или роль 'LAB10' не существует

https://docs.oracle.com/error-help/db/ora-01917/01917. 00000 -  "user or role '%s' does not exist"
*Cause:    A user or role by that name did not exist.
*Action:   Re-specify the name.
SQL> 
SQL> -- PROMPT Drop Emulation user
SQL> -- drop user Emulation cascade;
SQL> 
SQL> PROMPT Create user Emulation
Create user Emulation
SQL> CREATE USER Emulation IDENTIFIED BY &&Emulation_password PASSWORD EXPIRE ACCOUNT LOCK /* DEFAULT TABLESPACE USERS  TEMPORARY TABLESPACE TEMP */;
old:CREATE USER Emulation IDENTIFIED BY &&Emulation_password PASSWORD EXPIRE ACCOUNT LOCK /* DEFAULT TABLESPACE USERS  TEMPORARY TABLESPACE TEMP */
new:CREATE USER Emulation IDENTIFIED BY "EWRe$pbqgKoqbl9h" PASSWORD EXPIRE ACCOUNT LOCK /* DEFAULT TABLESPACE USERS  TEMPORARY TABLESPACE TEMP */

Error starting at line : 31 File @ D:\univer\!МСХОАД\migrate\migrationRepo\generated\2025-02-18_10-02-17\master.sql
In command -
CREATE USER Emulation IDENTIFIED BY &&Emulation_password PASSWORD EXPIRE ACCOUNT LOCK /* DEFAULT TABLESPACE USERS  TEMPORARY TABLESPACE TEMP */
Error report -
ORA-65096: недопустимое имя общего пользователя или имя роли

https://docs.oracle.com/error-help/db/ora-65096/65096. 00000 -  "common user or role name must start with prefix %s"
*Cause:    An attempt is being made to create a common user or role without
           the correct prefix as specified in the COMMON_USER_PREFIX
           parameter.
*Action:   Specify a valid common user or role name with the correct prefix.
*Params:   1) common_user_prefix
           parameter.
SQL> GRANT CREATE SESSION, RESOURCE, CREATE VIEW, CREATE MATERIALIZED VIEW, CREATE SYNONYM, UNLIMITED TABLESPACE TO Emulation;

Error starting at line : 32 File @ D:\univer\!МСХОАД\migrate\migrationRepo\generated\2025-02-18_10-02-17\master.sql
In command -
GRANT CREATE SESSION, RESOURCE, CREATE VIEW, CREATE MATERIALIZED VIEW, CREATE SYNONYM, UNLIMITED TABLESPACE TO Emulation
Error report -
ORA-01917: пользователь или роль 'EMULATION' не существует

https://docs.oracle.com/error-help/db/ora-01917/01917. 00000 -  "user or role '%s' does not exist"
*Cause:    A user or role by that name did not exist.
*Action:   Re-specify the name.
SQL> 
SQL> set define on
SQL> prompt connecting to Emulation
connecting to Emulation
SQL> alter session set current_schema=Emulation;

Error starting at line : 36 File @ D:\univer\!МСХОАД\migrate\migrationRepo\generated\2025-02-18_10-02-17\master.sql
In command -
alter session set current_schema=Emulation
Error report -
ORA-01435: такого пользователя не существует

https://docs.oracle.com/error-help/db/ora-01435/01435. 00000 -  "user does not exist"
*Cause:    This message is caused by any reference to a
           non-existent user. For example, it occurs if a SELECT, GRANT,
           or REVOKE statement specifies a username that did not exist.
           Only a GRANT CONNECT statement may specify a new username. All
           other GRANT and REVOKE statements must specify existing
           usernames. If specified in a SELECT statement, usernames must
           already exist.
*Action:   Specify only existing usernames in the SELECT, GRANT,
           or REVOKE statement or ask the database administrator to
           define the new username.
SQL> set define off
SQL> create PACKAGE UTILS AS
  2  SQLSERVER           VARCHAR2(10)  := 'SQLSERVER';
  3  SYBASE              VARCHAR2(10)  := 'SYBASE';
  4  DATABASE_TYPE       VARCHAR2(10)  :=  SQLSERVER;
  5  
  6  IDENTITY_VALUE   NUMBER(10);
  7  TRANCOUNT  NUMBER(10):=0;
  8  VAR_NUMBER NUMBER(10):=0;
  9  SUBTYPE ts is timestamp(9) ;
 10  SUBTYPE tstz is timestamp(9) with time zone;
 11  
 12  TYPE IDENTITY_TYPE IS TABLE OF NUMBER INDEX BY VARCHAR2(200);
 13  identitymap identity_type;
 14  FUNCTION  IDENTITY( V_IDENTITYID VARCHAR2, V_SEED INT DEFAULT 1,V_INCREMENT  INT DEFAULT 1) RETURN NUMBER;
 15  PROCEDURE IDENTITY_RESET( V_IDENTITYID VARCHAR2);
 16  
 17  FUNCTION BIGINTTOHEX(P_EXPR NUMBER) RETURN VARCHAR2;
 18  FUNCTION BIGINTTOHEX(P_EXPR RAW)    RETURN VARCHAR2;
 19  
 20  FUNCTION BIT_XOR(P_RAW1 RAW   ,P_RAW2 RAW)    RETURN RAW;
 21  FUNCTION BIT_XOR(P_NUM1 NUMBER,P_NUM2 NUMBER) RETURN NUMBER;
 22  
 23  FUNCTION BIT_OR(P_RAW1 RAW    ,P_RAW2 RAW)    RETURN RAW;
 24  FUNCTION BIT_OR(P_NUM1 NUMBER ,P_NUM2 NUMBER) RETURN NUMBER;
 25  
 26  FUNCTION BIT_AND(P_RAW1 RAW   ,P_RAW2 RAW)    RETURN RAW;
 27  FUNCTION BIT_AND(P_NUM1 NUMBER,P_NUM2 NUMBER) RETURN NUMBER;
 28  FUNCTION BIT_AND(P_NUM1 NUMBER   ,P_RAW1 RAW) RETURN RAW;
 29  FUNCTION BIT_AND(P_RAW1 RAW,P_NUM1 NUMBER) RETURN RAW;
 30  
 31  FUNCTION BIT_COMPLIMENT(P_RAW1 RAW )    RETURN RAW;
 32  FUNCTION BIT_COMPLIMENT(P_NUM1 NUMBER) RETURN NUMBER;
 33  
 34  FUNCTION CONVERT_TO_BLOB    (P_EXPR IN VARCHAR2                 ,P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0     ,P_STYLE IN NUMBER DEFAULT 0) RETURN BLOB;
 35  FUNCTION CONVERT_TO_BLOB    (P_EXPR IN NUMBER                   ,P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0     ,P_STYLE IN NUMBER DEFAULT 0) RETURN BLOB;
 36  
 37  FUNCTION CONVERT_TO_RAW     (P_EXPR IN VARCHAR2, P_PRECISION IN NUMBER DEFAULT 0, P_SCALE IN NUMBER DEFAULT 0, P_STYLE IN NUMBER DEFAULT 0) RETURN RAW;
 38  
 39  FUNCTION CONVERT_TO_DATE	  (P_EXPR IN TSTZ	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE;
 40  FUNCTION CONVERT_TO_DATE	  (P_EXPR IN TS              , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE;
 41  FUNCTION CONVERT_TO_DATE	  (P_EXPR IN DATE	                    , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE;
 42  FUNCTION CONVERT_TO_DATE	  (P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE;
 43  
 44  FUNCTION CONVERT_TO_DATETIME	  (P_EXPR IN TSTZ	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS;
 45  FUNCTION CONVERT_TO_DATETIME	  (P_EXPR IN TS              , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS;
 46  FUNCTION CONVERT_TO_DATETIME	  (P_EXPR IN DATE	                    , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS;
 47  FUNCTION CONVERT_TO_DATETIME	  (P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS;
 48  
 49  FUNCTION CONVERT_TO_SMALLDATETIME	  (P_EXPR IN TSTZ	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE;
 50  FUNCTION CONVERT_TO_SMALLDATETIME	  (P_EXPR IN TS              , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE;
 51  FUNCTION CONVERT_TO_SMALLDATETIME	  (P_EXPR IN DATE	                    , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE;
 52  FUNCTION CONVERT_TO_SMALLDATETIME	  (P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE;
 53  
 54  FUNCTION CONVERT_TO_TIMESTAMP	      (P_EXPR IN VARCHAR2	                 , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS;
 55  FUNCTION CONVERT_TO_TIMESTAMP	      (P_EXPR IN DATE	                     , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS;
 56  FUNCTION CONVERT_TO_TIMESTAMP	      (P_EXPR IN TS	               , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS;
 57  FUNCTION CONVERT_TO_TIMESTAMP	      (P_EXPR IN TSTZ	 , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS;
 58  
 59  FUNCTION CONVERT_TO_NUMBER	(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN NUMBER;
 60  FUNCTION CONVERT_TO_NUMBER	(P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN NUMBER;
 61  FUNCTION CONVERT_TO_NUMBER  (P_BLOB_EXPR IN BLOB                     , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN NUMBER;
 62  
 63  FUNCTION CONVERT_TO_FLOAT	  (P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN FLOAT;
 64  FUNCTION CONVERT_TO_FLOAT	  (P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN FLOAT;
 65  
 66  FUNCTION CONVERT_TO_VARCHAR2	(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN VARCHAR2;
 67  FUNCTION CONVERT_TO_VARCHAR2	(P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN VARCHAR2;
 68  FUNCTION CONVERT_TO_VARCHAR2	(P_EXPR IN DATE		                  , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN VARCHAR2;
 69  FUNCTION CONVERT_TO_VARCHAR2	(P_EXPR IN TS		            , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN VARCHAR2;
 70  FUNCTION CONVERT_TO_VARCHAR2	(P_EXPR IN TSTZ	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN VARCHAR2;
 71  FUNCTION CONVERT_TO_VARCHAR2  (P_EXPR IN BLOB                     , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT 0)    RETURN VARCHAR2;
 72  
 73  FUNCTION CONVERT_TO_NVARCHAR2	(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN NVARCHAR2;
 74  FUNCTION CONVERT_TO_NVARCHAR2	(P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN NVARCHAR2;
 75  FUNCTION CONVERT_TO_NVARCHAR2	(P_EXPR IN DATE		                  , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN NVARCHAR2;
 76  FUNCTION CONVERT_TO_NVARCHAR2	(P_EXPR IN TS		            , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN NVARCHAR2;
 77  FUNCTION CONVERT_TO_NVARCHAR2	(P_EXPR IN TSTZ	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN NVARCHAR2;
 78  
 79  FUNCTION CONVERT_TO_CHAR	(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR;
 80  FUNCTION CONVERT_TO_CHAR	(P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR;
 81  FUNCTION CONVERT_TO_CHAR	(P_EXPR IN DATE		                  , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR;
 82  FUNCTION CONVERT_TO_CHAR	(P_EXPR IN TS		            , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR;
 83  FUNCTION CONVERT_TO_CHAR	(P_EXPR IN TSTZ	, P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR;
 84  
 85  FUNCTION CONVERT_TO_CLOB	(P_EXPR IN CLOB	                    , P_PRECISION IN NUMBER DEFAULT 4000, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB;
 86  FUNCTION CONVERT_TO_CLOB	(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT 4000, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB;
 87  FUNCTION CONVERT_TO_CLOB	(P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT 4000, P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB;
 88  FUNCTION CONVERT_TO_CLOB	(P_EXPR IN DATE		                  , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB;
 89  FUNCTION CONVERT_TO_CLOB	(P_EXPR IN TS		            , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB;
 90  FUNCTION CONVERT_TO_CLOB	(P_EXPR IN TSTZ	, P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB;
 91  
 92  FUNCTION DATENAME(P_PART_EXPR IN VARCHAR2, P_DATE_STR IN VARCHAR2)  RETURN VARCHAR2;
 93  FUNCTION DATENAME(P_PART_EXPR IN VARCHAR2, P_DATE_EXPR IN DATE)  RETURN VARCHAR2;
 94  FUNCTION DATENAME(P_PART_EXPR IN VARCHAR2, P_DATE_EXPR IN TS)  RETURN VARCHAR2;
 95  FUNCTION DATENAME(P_PART_EXPR IN VARCHAR2, P_DATE_EXPR IN TSTZ)  RETURN VARCHAR2;
 96  
 97  FUNCTION DATEPART(P_PART_EXPR IN VARCHAR2, P_DATE_STR IN VARCHAR2)  RETURN NUMBER;
 98  FUNCTION DATEPART(P_PART_EXPR IN VARCHAR2, P_DATE_EXPR IN DATE)  RETURN NUMBER;
 99  FUNCTION DATEPART(P_PART_EXPR IN VARCHAR2, P_DATE_EXPR IN TS)  RETURN NUMBER;
100  FUNCTION DATEPART(P_PART_EXPR IN VARCHAR2, P_DATE_EXPR IN TSTZ) RETURN NUMBER;
101  
102  FUNCTION DATEADD(P_INTERVAL IN VARCHAR2, P_INTERVAL_VAL IN NUMBER, P_DATE_STR IN VARCHAR2) RETURN TS;
103  FUNCTION DATEADD(P_INTERVAL IN VARCHAR2, P_INTERVAL_VAL IN NUMBER, P_DATE_EXPR IN DATE) RETURN DATE;
104  FUNCTION DATEADD(P_INTERVAL IN VARCHAR2, P_INTERVAL_VAL IN NUMBER, P_DATE_EXPR IN TS) RETURN TS;
105  FUNCTION DATEADD(P_INTERVAL IN VARCHAR2, P_INTERVAL_VAL IN NUMBER, P_DATE_EXPR IN TSTZ) RETURN TS;
106  
107  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_STR IN VARCHAR2, P_END_DATE_STR IN VARCHAR2) RETURN NUMBER;
108  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_STR IN VARCHAR2, P_END_DATE_EXPR IN DATE) RETURN NUMBER;
109  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_STR IN VARCHAR2, P_END_DATE_EXPR IN NUMBER) RETURN NUMBER;
110  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_STR IN VARCHAR2, P_END_DATE_EXPR IN TS) RETURN NUMBER;
111  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_STR IN VARCHAR2, P_END_DATE_EXPR IN TSTZ) RETURN NUMBER;
112  
113  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN DATE, P_END_DATE_EXPR IN DATE) RETURN NUMBER;
114  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN DATE, P_END_DATE_EXPR IN NUMBER) RETURN NUMBER;
115  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN DATE, P_END_DATE_STR IN VARCHAR2) RETURN NUMBER;
116  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN DATE, P_END_DATE_EXPR IN TS) RETURN NUMBER;
117  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN DATE, P_END_DATE_EXPR IN TSTZ) RETURN NUMBER;
118  
119  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN NUMBER, P_END_DATE_EXPR IN DATE) RETURN NUMBER;
120  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN NUMBER, P_END_DATE_EXPR IN NUMBER) RETURN NUMBER;
121  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN NUMBER, P_END_DATE_STR IN VARCHAR2) RETURN NUMBER;
122  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN NUMBER, P_END_DATE_EXPR IN TS) RETURN NUMBER;
123  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN NUMBER, P_END_DATE_EXPR IN TSTZ) RETURN NUMBER;
124  
125  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TS, P_END_DATE_EXPR IN TS) RETURN NUMBER;
126  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TS, P_END_DATE_EXPR IN DATE) RETURN NUMBER;
127  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TS, P_END_DATE_EXPR IN NUMBER) RETURN NUMBER;
128  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TS, P_END_DATE_STR IN VARCHAR2) RETURN NUMBER;
129  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TS, P_END_DATE_EXPR IN TSTZ) RETURN NUMBER;
130  
131  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TSTZ, P_END_DATE_EXPR IN TSTZ) RETURN NUMBER;
132  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TSTZ, P_END_DATE_EXPR IN TS) RETURN NUMBER;
133  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TSTZ, P_END_DATE_EXPR IN DATE) RETURN NUMBER;
134  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TSTZ, P_END_DATE_EXPR IN NUMBER) RETURN NUMBER;
135  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TSTZ, P_END_DATE_STR IN VARCHAR2) RETURN NUMBER;
136  
137  FUNCTION ZERODATETIME RETURN DATE;
138  
139  FUNCTION YEAR_(P_DATE_STR    IN VARCHAR2) RETURN NUMBER;
140  FUNCTION YEAR_(P_DATE_EXPR   IN DATE) RETURN NUMBER;
141  FUNCTION YEAR_(P_DATE_EXPR   IN TS) RETURN NUMBER;
142  FUNCTION YEAR_(P_DATE_EXPR   IN TSTZ) RETURN NUMBER;
143  
144  FUNCTION MONTH_(P_DATE_STR  IN VARCHAR2) RETURN NUMBER;
145  FUNCTION MONTH_(P_DATE_EXPR  IN DATE) RETURN NUMBER;
146  FUNCTION MONTH_(P_DATE_EXPR  IN TS) RETURN NUMBER;
147  FUNCTION MONTH_(P_DATE_EXPR  IN TSTZ) RETURN NUMBER;
148  
149  FUNCTION DAY_(P_DATE_STR     IN VARCHAR2) RETURN NUMBER;
150  FUNCTION DAY_(P_DATE_EXPR    IN DATE)     RETURN NUMBER;
151  FUNCTION DAY_(P_DATE_EXPR    IN TS) RETURN NUMBER;
152  FUNCTION DAY_(P_DATE_EXPR    IN TSTZ) RETURN NUMBER;
153  
154  FUNCTION STUFF(P_EXPR VARCHAR2, P_STARTIDX NUMBER, P_LEN NUMBER, P_REPLACE_EXPR VARCHAR2)  RETURN VARCHAR2;
155  FUNCTION REVERSE_(P_EXPR IN VARCHAR2)                                                      RETURN VARCHAR2;
156  FUNCTION QUOTENAME(P_STR IN VARCHAR2, P_DELIMITERS IN VARCHAR2 DEFAULT '[]')               RETURN VARCHAR2;
157  FUNCTION PARSENAME(P_OBJECT_NAME IN VARCHAR2, P_OBJECT_PIECE IN NUMBER)                    RETURN VARCHAR2;
158  FUNCTION DIFFERENCE(P_EXPR1 IN VARCHAR2, P_EXPR2 IN VARCHAR2)                              RETURN NUMBER;
159  FUNCTION PATINDEX(P_PATTERN IN VARCHAR2, P_EXPR IN VARCHAR2, P_FORMAT IN VARCHAR2 DEFAULT 'USING CHARS') RETURN NUMBER;
160  
161  --NOTE THESE ALL NEED TO BE OVERRIDDEN WITH TIMESTAMP,TIMESTAMP TZ AND DATE DATA TYPES . LETS TEST REST FIRST
162  FUNCTION STATS_DATE(P_TABLE IN VARCHAR2,  P_INDEX IN VARCHAR2) RETURN DATE;
163  
164  FUNCTION ISDATE(P_EXPR      IN VARCHAR2) RETURN NUMBER;
165  FUNCTION ISNUMERIC(P_EXPR IN VARCHAR2)       RETURN NUMBER;
166  FUNCTION DEGREES(P_ANGLE_RADIANS IN NUMBER)  RETURN NUMBER;
167  FUNCTION RADIANS(P_DEGREE IN NUMBER)         RETURN NUMBER;
168  FUNCTION ROUND_(P_EXPR NUMBER, P_LEN NUMBER, P_FUNCTION NUMBER DEFAULT 0)  RETURN NUMBER;
169  FUNCTION RAND(P_SEED NUMBER DEFAULT NULL)    RETURN NUMBER;
170  FUNCTION OCT(P_NUM VARCHAR2)                 RETURN VARCHAR2;
171  FUNCTION HEX(P_NUM VARCHAR2)                 RETURN VARCHAR2;
172  FUNCTION TO_BASE(P_DEC NUMBER, P_BASE NUMBER)RETURN VARCHAR2;
173  FUNCTION TO_SECOND(P_TIME VARCHAR2) RETURN NUMBER;
174  
175  FUNCTION STR(P_EXPR IN NUMBER, P_LEN IN NUMBER DEFAULT 10, P_SCALE IN NUMBER DEFAULT 0)  RETURN VARCHAR2;
176  FUNCTION PI RETURN NUMBER;
177  
178  PROCEDURE COMMIT_TRANSACTION;
179  FUNCTION  COMMIT_TRANSACTION_STATE RETURN NUMBER;
180  PROCEDURE RESETTRANCOUNT;
181  PROCEDURE DECREMENTTRANCOUNT;
182  PROCEDURE INCREMENTTRANCOUNT;
183  FUNCTION GETIDENTITY RETURN NUMBER;
184  FUNCTION IDENT_INCR(P_SEQUENCE IN VARCHAR2)     RETURN NUMBER;
185  FUNCTION FETCH_STATUS(P_CURSORFOUND IN BOOLEAN) RETURN NUMBER;
186  FUNCTION SQLSTATUS(P_CURSORFOUND IN BOOLEAN,P_CURSOROPEN IN BOOLEAN) RETURN NUMBER;
187  FUNCTION IDENT_SEED(P_SEQUENCE IN VARCHAR2) RETURN NUMBER;
188  FUNCTION SPID RETURN NUMBER;
189  PROCEDURE SET_DATABASE_TYPE (P_DATABASE_TYPE IN VARCHAR2);
190  
191  FUNCTION LICENSE_ENABLED(SERVER IN VARCHAR2 DEFAULT 'ase_server') RETURN PLS_INTEGER;
192  FUNCTION OBJECT_ID(OBJECTREF VARCHAR2) RETURN INT;
193  PROCEDURE RAISERROR(ERRORCODE NUMBER,MSG VARCHAR2);
194  PROCEDURE HANDLEERROR(ERRORCODE NUMBER,MSG VARCHAR2);
195  FUNCTION error_line      RETURN VARCHAR2;
196  FUNCTION error_procedure RETURN VARCHAR2;
197  FUNCTION error_severity  RETURN VARCHAR2;
198  FUNCTION error_state     RETURN VARCHAR2;
199  end utils;
200  /

Package UTILS compiled

SQL> 
SQL> create PACKAGE BODY UTILS AS
  2  
  3  TYPE VARCHAR2_ARRAY IS TABLE OF VARCHAR2(100);
  4  DT_FORMATS          VARCHAR2_ARRAY; -- Customer : Please Modify the List of Date/Timestamp Formats so that the most common T-SQL literals are at the top
  5  DT_DAY              VARCHAR2_ARRAY; -- Datetime formats starting with Day
  6  DT_MONTH            VARCHAR2_ARRAY; -- Datetime formats starting with Month
  7  DT_YEAR             VARCHAR2_ARRAY; -- Datetime formats starting with Year
  8  DT_TIME             VARCHAR2_ARRAY; -- Datetime formats just having Hour, Minute, Second and Fractional seconds
  9  DT_NLS              VARCHAR2_ARRAY; -- Oracle NLS DateTime formats
 10  DT_TIMESTAMP        VARCHAR2_ARRAY; -- Oracle TIMESTAMP formats
 11  
 12  DEFAULT_CHAR_SIZE NUMBER := 30;    
 13  
 14  FUNCTION ZERODATETIME RETURN DATE
 15  IS
 16  BEGIN
 17    RETURN TO_DATE('1900-01-01','yyyy-mm-dd');
 18  END;
 19  
 20  FUNCTION LICENSE_ENABLED 
 21  (
 22    SERVER IN VARCHAR2 DEFAULT 'ase_server' 
 23  ) RETURN pls_integer AS 
 24  RET_VAL NUMBER := 0;
 25  BEGIN
 26    IF 
 27          (lower(SERVER) = 'ase_server' 
 28    OR lower(SERVER) = 'ase_ha' 
 29    OR lower(SERVER) = 'ase_dtm' 
 30    OR lower(SERVER) = 'ase_java' 
 31    OR lower(SERVER) = 'ase_asm')
 32    THEN return 1;
 33    ELSE return 0 ;
 34    END IF;
 35  END LICENSE_ENABLED;
 36  -- PRIVATE 
 37  FUNCTION GET_FORMAT_FROM_STYLE(P_STYLE NUMBER) RETURN VARCHAR2
 38  IS
 39  V_FORMAT VARCHAR2(50);
 40  BEGIN
 41  IF DATABASE_TYPE = SYBASE THEN --http://infocenter.sybase.com/help/index.jsp?topic=/com.sybase.help.ase_15.0.blocks/html/blocks/blocks125.htm
 42  V_FORMAT := CASE 
 43  
 44                  WHEN P_STYLE = 0   THEN  'Mon DD YYYY HH12:MI AM'
 45                  WHEN P_STYLE = 100 THEN  'Mon DD YYYY HH12:MI AM'
 46                  WHEN P_STYLE = 1   THEN  'MM/DD/YY'
 47                  WHEN P_STYLE = 101 THEN  'MM/DD/YYYY'
 48                  WHEN P_STYLE = 2   THEN  'YY.MM.DD'
 49                  WHEN P_STYLE = 102 THEN  'YYYY.MM.DD'
 50                  WHEN P_STYLE = 3   THEN  'DD/MM/YY'
 51                  WHEN P_STYLE = 103 THEN  'DD/MM/YYYY'
 52                  WHEN P_STYLE = 4   THEN  'DD.MM.YY'
 53                  WHEN P_STYLE = 104 THEN  'DD.MM.YYYY'
 54                  WHEN P_STYLE = 5   THEN  'DD-MM-YY'
 55                  WHEN P_STYLE = 105 THEN  'DD-MM-YYYY'
 56                  WHEN P_STYLE = 6   THEN  'DD Mon YY'
 57                  WHEN P_STYLE = 106 THEN  'DD Mon YYYY'
 58                  WHEN P_STYLE = 7   THEN  'Mon DD, YY'
 59                  WHEN P_STYLE = 107 THEN  'Mon DD, YYYY'
 60                  WHEN P_STYLE = 8   THEN  'HH24:MI:SS'
 61                  WHEN P_STYLE = 108 THEN  'HH24:MI:SS'
 62                  WHEN P_STYLE = 9   THEN  'FMMon  DD YYYY  HH12:MI:SS:FF3AM'
 63                  WHEN P_STYLE = 109 THEN  'FMMon  DD YYYY  HH12:MI:SS:FF3AM'
 64                  WHEN P_STYLE = 10  THEN  'MM-DD-YY'
 65                  WHEN P_STYLE = 110 THEN  'MM-DD-YYYY'
 66                  WHEN P_STYLE = 11  THEN  'YY/MM/DD'
 67                  WHEN P_STYLE = 111 THEN  'YYYY/MM/DD'
 68                  WHEN P_STYLE = 12  THEN  'YYMMDD' -- Different from the doc. Testing suggests this is the actual format
 69                  WHEN P_STYLE = 112 THEN  'YYYYMMDD' -- Different from the doc. Testing suggests this is the actual format
 70                  WHEN P_STYLE = 13  THEN  'YY/DD/MM' -- Different from the doc. Testing suggests this is the actual format
 71                  WHEN P_STYLE = 113 THEN  'YYYY/DD/MM'
 72                  WHEN P_STYLE = 14  THEN  'MM/YY/DD' -- Different from the doc. Testing suggests this is the actual format
 73                  WHEN P_STYLE = 114 THEN  'MM/YYYY/DD' -- Different from the doc. Testing suggests this is the actual format
 74                  WHEN P_STYLE = 15  THEN  'DD/YY/MM'
 75                  WHEN P_STYLE = 115 THEN  'DD/YYYY/MM'
 76                  WHEN P_STYLE = 16  THEN  'Mon  fmDDfm YYYY HH24:MI:SS'
 77                  WHEN P_STYLE = 116 THEN  'Mon  fmDDfm YYYY HH24:MI:SS'
 78                  WHEN P_STYLE = 17  THEN  'FMHH12:MIAM'
 79                  WHEN P_STYLE = 117 THEN  'YYYY/MM/DD HH:MI:SS' -- Different from the doc. Testing suggests this is the actual format
 80                  WHEN P_STYLE = 18  THEN  'HH24:MI'
 81                  WHEN P_STYLE = 118 THEN  'YYYY/MM/DD FMHH12:MIAM' -- Different from the doc. Testing suggests this is the actual format
 82                  WHEN P_STYLE = 19  THEN  'FMHH12:MI:SS:FF3AM'
 83                  WHEN P_STYLE = 119 THEN  'FMHH12:MI:SS:FF3AM'        
 84                  WHEN P_STYLE = 20  THEN  'HH24:MI:SS:FF3'
 85                  WHEN P_STYLE = 120 THEN  'HH24:MI:SS:FF3'
 86                  WHEN P_STYLE = 21  THEN  'YY/MM/DD HH:MI:SS' -- Different from the doc. Testing suggests this is the actual format
 87                  WHEN P_STYLE = 121 THEN  'YYYY/MM/DD HH:MI:SS' -- Different from the doc. Testing suggests this is the actual format
 88                  WHEN P_STYLE = 22  THEN  'YY/MM/DD  fmHH:MIAM'
 89                  WHEN P_STYLE = 122 THEN  'YYYY/MM/DD  fmHH:MIAM'
 90                  WHEN P_STYLE = 23  THEN  'YYYY-MM-DD"T"HH12:MI:SS' -- Different from the doc. Testing suggests this is the actual format
 91                  WHEN P_STYLE = 123 THEN  'YYYY-MM-DD"T"HH12:MI:SS' -- Different from the doc. Testing suggests this is the actual format
 92                  END;
 93  END IF;
 94  IF DATABASE_TYPE = SQLSERVER THEN
 95  V_FORMAT := CASE 
 96                  WHEN P_STYLE = 0   THEN  'MON DD YYYY HH12:MIAM'
 97                  WHEN P_STYLE = 100 THEN  'MON DD YYYY HH12:MIAM'
 98                  WHEN P_STYLE = 1   THEN  'MM/DD/YY'
 99                  WHEN P_STYLE = 101 THEN  'MM/DD/YYYY'
100                  WHEN P_STYLE = 2   THEN  'YY.MM.DD'
101                  WHEN P_STYLE = 102 THEN  'YYYY.MM.DD'
102                  WHEN P_STYLE = 3   THEN  'DD/MM/YY'
103                  WHEN P_STYLE = 103 THEN  'DD/MM/YYYY'
104                  WHEN P_STYLE = 4   THEN  'DD.MM.YY'
105                  WHEN P_STYLE = 104 THEN  'DD.MM.YYYY'
106                  WHEN P_STYLE = 5   THEN  'DD-MM-YY'
107                  WHEN P_STYLE = 105 THEN  'DD-MM-YYYY'
108                  WHEN P_STYLE = 6   THEN  'DD Mon YY'
109                  WHEN P_STYLE = 106 THEN  'DD Mon YYYY'
110                  WHEN P_STYLE = 7   THEN  'Mon DD, YY'
111                  WHEN P_STYLE = 107 THEN  'Mon DD, YYYY'
112                  WHEN P_STYLE = 8   THEN  'HH24:MI:SS'
113                  WHEN P_STYLE = 108 THEN  'HH24:MI:SS'
114                  WHEN P_STYLE = 9   THEN  'FMMon  DD YYYY  HH12:MI:SS:FF3AM'
115                  WHEN P_STYLE = 109 THEN  'FMMon  DD YYYY  HH12:MI:SS:FF3AM'
116                  WHEN P_STYLE = 10  THEN  'MM-DD-YY'
117                  WHEN P_STYLE = 110 THEN  'MM-DD-YYYY'
118                  WHEN P_STYLE = 11  THEN  'YY/MM/DD'
119                  WHEN P_STYLE = 111 THEN  'YYYY/MM/DD'
120                  WHEN P_STYLE = 12  THEN  'YYMMDD'
121                  WHEN P_STYLE = 112 THEN  'YYYYMMDD'
122                  WHEN P_STYLE = 13  THEN  'DD Mon YYYY HH24:MI:SS:FF3'
123                  WHEN P_STYLE = 113 THEN  'DD Mon YYYY HH24:MI:SS:FF3'
124                  WHEN P_STYLE = 14  THEN  'HH24:MI:SS:FF3'
125                  WHEN P_STYLE = 114 THEN  'HH24:MI:SS:FF3'
126                  WHEN P_STYLE = 20  THEN  'YYYY-MM-DD HH24:MI:SS'
127                  WHEN P_STYLE = 120 THEN  'MM/DD/YY  HH12:MI:SS AM'
128                  WHEN P_STYLE = 21  THEN  'YYYY-MM-DD HH24:MI:SS.FF3'
129                  WHEN P_STYLE = 22  THEN  'MM/DD/YY  FMHH12:MI:SS AM'
130                  WHEN P_STYLE = 122 THEN  'MM/DD/YY  FMHH12:MI:SS AM'
131                  WHEN P_STYLE = 23  THEN  'YYYY-MM-DD'
132                  WHEN P_STYLE = 123 THEN  'YYYY-MM-DD'
133                  WHEN P_STYLE = 121 THEN  'YYYY-MM-DD HH24:MI:SS.FF3'
134                  WHEN P_STYLE = 126 THEN  'YYYY-MM-DD HH12:MI:SS.FF3'
135                  WHEN P_STYLE = 127 THEN  'YYYY-MM-DD HH12:MI:SS.FF3'
136                  WHEN P_STYLE = 130 THEN  'DD Mon YYYY HH12:MI:SS:FF3AM'
137                  WHEN P_STYLE = 131 THEN  'DD/MM/YY HH12:MI:SS:FF3AM' 
138                  END;
139  END IF;
140  
141  RETURN V_FORMAT;                
142  END;
143  
144  FUNCTION CONVERT_STRING_TO_TIMESTAMP (ARG VARCHAR2) RETURN TS
145    AS
146    BEGIN
147     FOR i in DT_FORMATS.FIRST .. DT_FORMATS.LAST
148     LOOP
149      BEGIN
150        RETURN TO_TIMESTAMP(ARG,DT_FORMATS(i));
151     EXCEPTION
152     WHEN OTHERS THEN
153        NULL; -- Keep Trying
154      END;
155     END LOOP;
156     --Attempt to cast one last time, but its really to designed to throw the error to the application when a string is not recognized
157     RETURN  TO_TIMESTAMP(ARG,DT_FORMATS(1));
158  END; 
159  
160  FUNCTION getNLSTSformat RETURN VARCHAR2
161  IS
162   ts_format VARCHAR2(50);
163  BEGIN
164    SELECT VALUE INTO ts_format FROM V$NLS_PARAMETERS WHERE PARAMETER = 'NLS_TIMESTAMP_FORMAT';
165    RETURN ts_format;
166  END getNLSTSformat;
167  
168  
169  FUNCTION getNLSDATEformat RETURN VARCHAR2
170  IS
171   dt_format VARCHAR2(50);
172  BEGIN
173    SELECT VALUE INTO dt_format FROM V$NLS_PARAMETERS WHERE PARAMETER = 'NLS_DATE_FORMAT';
174    RETURN DT_FORMAT;
175  END getNLSDATEformat;
176  
177  FUNCTION PI RETURN NUMBER
178  IS
179      pi NUMBER := 3.141592653589793116;
180  BEGIN
181      RETURN PI;
182  END PI;
183  
184  FUNCTION BIGINTTOHEX(P_EXPR NUMBER) RETURN VARCHAR2
185  IS
186      l_number NUMBER;
187    BEGIN
188      l_number       := P_EXPR;
189      -- Need to make sure that we protect against limitation on boundary condition
190      IF l_number    <= -2147483647 THEN
191        l_number     := -2147483647;
192      ELSIF l_number >= 2147483647 THEN
193        l_number     := 2147483647;
194      END IF;
195      RETURN RAWTOHEX(UTL_RAW.CAST_FROM_BINARY_INTEGER(l_number)) ;
196  END;
197  
198  FUNCTION BIGINTTOHEX(P_EXPR RAW) RETURN VARCHAR2
199  IS
200  BEGIN
201    RETURN RAWTOHEX(P_EXPR);
202  END biginttohex;
203  
204  FUNCTION BIT_XOR(P_RAW1 RAW   ,P_RAW2 RAW) RETURN RAW
205  IS
206  BEGIN
207  RETURN  UTL_RAW.BIT_XOR(p_raw1,p_raw2);
208  END;
209  
210  FUNCTION BIT_XOR(P_NUM1 NUMBER,P_NUM2 NUMBER) RETURN NUMBER
211  IS BEGIN
212  RETURN BIT_OR(P_NUM1,P_NUM2) - BITAND(P_NUM1,P_NUM2);
213  END;
214  
215  FUNCTION BIT_OR(P_RAW1 RAW    ,P_RAW2 RAW) RETURN RAW
216  IS BEGIN
217  RETURN  UTL_RAW.BIT_OR(p_raw1,p_raw2);
218  END;
219  
220  FUNCTION BIT_OR(P_NUM1 NUMBER ,P_NUM2 NUMBER) RETURN NUMBER
221  IS BEGIN
222  RETURN P_NUM1 + P_NUM2 - BITAND(P_NUM1,P_NUM2);
223  END;
224  
225  FUNCTION BIT_AND(P_NUM1 NUMBER   ,P_RAW1 RAW) RETURN RAW
226  IS BEGIN
227  RETURN  UTL_RAW.BIT_AND(utl_raw.cast_from_number(p_num1),p_raw1);
228  END;
229  
230  FUNCTION BIT_AND(P_RAW1 RAW,P_NUM1 NUMBER) RETURN RAW
231  IS BEGIN
232  RETURN UTL_RAW.BIT_AND(p_raw1,utl_raw.cast_from_number(p_num1));
233  END;
234  
235  
236  FUNCTION BIT_AND(P_RAW1 RAW   ,P_RAW2 RAW) RETURN RAW
237  IS BEGIN
238  RETURN  UTL_RAW.BIT_AND(p_raw1,p_raw2);
239  END;
240  
241  FUNCTION BIT_AND(P_NUM1 NUMBER,P_NUM2 NUMBER) RETURN NUMBER 
242  IS BEGIN
243  RETURN  BITAND(P_NUM1,P_NUM2);
244  END;
245  
246  FUNCTION BIT_COMPLIMENT(P_RAW1 RAW) RETURN RAW
247  IS BEGIN
248    RETURN UTL_RAW.BIT_COMPLEMENT(p_raw1);
249  END;
250  
251  FUNCTION BIT_COMPLIMENT(P_NUM1 NUMBER) RETURN NUMBER
252  IS BEGIN
253  RETURN  -(P_NUM1 +1);
254  END;
255  
256  FUNCTION CONVERT_TO_TIMESTAMP(P_EXPR IN TS	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS
257  IS BEGIN
258    RETURN P_EXPR;
259  END;
260  
261  FUNCTION CONVERT_TO_TIMESTAMP(P_EXPR IN TSTZ	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS
262  IS BEGIN
263    RETURN CONVERT_TO_TIMESTAMP(CAST(P_EXPR AS TS),P_PRECISION,P_SCALE,P_STYLE);
264  END;
265  
266  FUNCTION CONVERT_TO_TIMESTAMP(P_EXPR IN DATE	                    , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS
267  IS BEGIN
268    RETURN P_EXPR;
269  END;
270  
271  FUNCTION CONVERT_TO_TIMESTAMP(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS
272  IS
273     v_format VARCHAR2(50);
274  BEGIN
275      IF P_STYLE IS NOT NULL THEN
276        V_FORMAT := GET_FORMAT_FROM_STYLE(P_STYLE);
277        RETURN TO_TIMESTAMP(P_EXPR, V_FORMAT);
278      ELSE
279        RETURN CONVERT_STRING_TO_TIMESTAMP(P_EXPR);
280      END IF;
281  EXCEPTION
282      WHEN OTHERS THEN
283        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
284  END;
285  
286  FUNCTION CONVERT_TO_DATETIME(P_EXPR IN TS	  , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS
287  IS BEGIN
288    RETURN CONVERT_TO_TIMESTAMP(P_EXPR,P_PRECISION,P_SCALE,P_STYLE); 
289  END;
290  
291  FUNCTION CONVERT_TO_DATETIME	  (P_EXPR IN TSTZ	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS
292  IS BEGIN
293    RETURN CONVERT_TO_DATETIME(CAST(P_EXPR AS TS),P_PRECISION,P_SCALE,P_STYLE); --REMOVE TZ
294  END;
295  
296  FUNCTION CONVERT_TO_DATETIME(P_EXPR IN DATE	  , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS
297  IS BEGIN
298    RETURN CONVERT_TO_TIMESTAMP(P_EXPR,P_PRECISION,P_SCALE,P_STYLE);
299  END;
300  
301  FUNCTION CONVERT_TO_DATETIME(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS
302  IS
303  BEGIN
304    RETURN CONVERT_TO_TIMESTAMP(P_EXPR,P_PRECISION,P_SCALE,P_STYLE);
305  END;
306  
307  FUNCTION CONVERT_TO_DATE	  (P_EXPR IN TSTZ	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE
308  IS BEGIN
309     RETURN CONVERT_TO_DATE(CAST(P_EXPR AS TS),P_PRECISION,P_SCALE,P_STYLE); --REMOVE TZ
310  END;
311  
312  FUNCTION CONVERT_TO_DATE	  (P_EXPR IN TS              , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE
313  IS BEGIN
314    RETURN TRUNC(CONVERT_TO_DATETIME(P_EXPR,P_PRECISION,P_SCALE,P_STYLE));
315  END;
316  
317  FUNCTION CONVERT_TO_DATE	  (P_EXPR IN DATE	                    , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE
318  IS BEGIN
319    RETURN TRUNC(CONVERT_TO_DATETIME(P_EXPR,P_PRECISION,P_SCALE,P_STYLE));
320  END;
321  
322  FUNCTION CONVERT_TO_DATE	  (P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE
323  IS BEGIN
324    RETURN TRUNC(CONVERT_TO_DATETIME(P_EXPR,P_PRECISION,P_SCALE,P_STYLE));
325  END;
326  
327  
328  
329  FUNCTION CONVERT_TO_SMALLDATETIME	  (P_EXPR IN TS              , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE
330  IS BEGIN
331    RETURN TRUNC(CONVERT_TO_DATETIME(P_EXPR,P_PRECISION,P_SCALE,P_STYLE),'MI');
332  END;
333  
334  FUNCTION CONVERT_TO_SMALLDATETIME	  (P_EXPR IN TSTZ	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE
335  IS BEGIN
336     RETURN CONVERT_TO_SMALLDATETIME(CAST(P_EXPR AS TS),P_PRECISION,P_SCALE,P_STYLE); --REMOVE TZ
337  END;
338  
339  FUNCTION CONVERT_TO_SMALLDATETIME	  (P_EXPR IN DATE	                    , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE
340  IS BEGIN
341    RETURN TRUNC(CONVERT_TO_DATETIME(P_EXPR,P_PRECISION,P_SCALE,P_STYLE),'MI');
342  END;
343  
344  FUNCTION CONVERT_TO_SMALLDATETIME	  (P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE
345  IS BEGIN
346    RETURN TRUNC(CONVERT_TO_DATETIME(P_EXPR,P_PRECISION,P_SCALE,P_STYLE),'MI');
347  END;
348  
349  FUNCTION CONVERT_TO_NUMBER	(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN NUMBER
350  IS BEGIN
351  RETURN P_EXPR;
352  END;
353  
354  FUNCTION CONVERT_TO_NUMBER	(P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN NUMBER
355  IS BEGIN
356  RETURN P_EXPR;
357  END;
358  
359  FUNCTION CONVERT_TO_FLOAT	  (P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN FLOAT
360  IS BEGIN
361    return P_EXPR;
362  END;
363  
364  FUNCTION CONVERT_TO_FLOAT	  (P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN FLOAT
365  IS BEGIN
366    return p_expr;
367  END;
368  
369  ---
370  FUNCTION CONVERT_TO_VARCHAR2	(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN VARCHAR2
371  IS BEGIN
372    RETURN P_EXPR;
373  END;
374  
375  FUNCTION CONVERT_TO_VARCHAR2	(P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN VARCHAR2
376  IS BEGIN
377    RETURN P_EXPR;
378  END;
379  
380  FUNCTION CONVERT_TO_VARCHAR2	(P_EXPR IN DATE		                  , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN VARCHAR2
381  IS
382     v_format VARCHAR2(50);
383     v_result VARCHAR2(100);
384  BEGIN
385    IF P_STYLE IS NOT NULL THEN
386      V_FORMAT := GET_FORMAT_FROM_STYLE(P_STYLE);
387      v_result := TO_CHAR(P_EXPR,V_FORMAT);  
388    ELSE
389      v_result := TO_CHAR(P_EXPR);
390    END IF;
391    IF P_PRECISION <> 0 THEN
392      v_result := SUBSTR(v_result,1,p_precision);
393    END IF;
394    RETURN v_result;
395  END;
396  
397  FUNCTION CONVERT_TO_VARCHAR2	(P_EXPR IN TS		            , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN VARCHAR2
398  IS
399     v_format VARCHAR2(50);
400  BEGIN
401    IF P_STYLE IS NOT NULL THEN
402      V_FORMAT := GET_FORMAT_FROM_STYLE(P_STYLE);
403      RETURN TO_CHAR(P_EXPR,V_FORMAT);  
404    ELSE
405      RETURN TO_CHAR(P_EXPR);
406    END IF;
407  END;
408  
409  FUNCTION CONVERT_TO_VARCHAR2	(P_EXPR IN TSTZ	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN VARCHAR2
410  IS BEGIN
411     RETURN CONVERT_TO_VARCHAR2(CAST(P_EXPR AS TS),P_PRECISION,P_SCALE,P_STYLE); --REMOVE TZ
412  END;
413  
414  FUNCTION CONVERT_TO_NUMBER(P_BLOB_EXPR IN BLOB, P_PRECISION IN NUMBER DEFAULT 0, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN NUMBER
415  IS
416    v_expr RAW(32767);
417  BEGIN
418      v_expr := DBMS_LOB.SUBSTR(P_BLOB_EXPR);
419      -- v_expr := REGEXP_REPLACE(v_expr, '0x', '', 1, 1, 'i');
420      RETURN UTL_RAW.CAST_TO_BINARY_INTEGER (v_expr, 3);  -- where 3 is machine_endian
421  END;
422  
423  FUNCTION CONVERT_TO_BLOB(P_EXPR IN NUMBER, P_PRECISION IN NUMBER DEFAULT 0, P_SCALE IN NUMBER DEFAULT 0, P_STYLE IN NUMBER DEFAULT 0) RETURN BLOB
424  IS
425  BEGIN
426     RETURN UTL_RAW.CAST_FROM_BINARY_INTEGER(P_EXPR, 3); -- where 3 is machine_endian
427  END;
428  
429  FUNCTION CONVERT_TO_RAW(P_EXPR IN VARCHAR2, P_PRECISION IN NUMBER DEFAULT 0, P_SCALE IN NUMBER DEFAULT 0, P_STYLE IN NUMBER DEFAULT 0) RETURN RAW
430  IS
431  BEGIN
432     RETURN UTL_RAW.CAST_TO_RAW ( P_EXPR ) ;
433  END;
434  
435  FUNCTION CONVERT_TO_VARCHAR2(P_EXPR IN BLOB, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT 0) RETURN VARCHAR2
436  IS
437    v_expr RAW(32767);
438  BEGIN
439     v_expr := DBMS_LOB.SUBSTR(P_EXPR);
440     RETURN UTL_RAW.CAST_TO_VARCHAR2(v_expr);
441  END;
442  
443  FUNCTION CONVERT_TO_BLOB(P_EXPR IN VARCHAR2, P_PRECISION IN NUMBER DEFAULT 0, P_SCALE IN NUMBER DEFAULT 0, P_STYLE IN NUMBER DEFAULT 0) RETURN BLOB
444  IS
445  BEGIN
446     RETURN UTL_RAW.CAST_TO_RAW(P_EXPR);
447  END;
448  
449  FUNCTION SUBSTR_(P_EXPR IN VARCHAR2,P_PRECISION IN NUMBER DEFAULT NULL) RETURN CHAR
450  AS
451  BEGIN
452    IF P_PRECISION IS  NULL THEN
453      RETURN SUBSTR(P_EXPR,1,DEFAULT_CHAR_SIZE);
454    ELSE
455      RETURN SUBSTR(P_EXPR,1,P_PRECISION);
456    END IF;
457  END;
458  --- MASTER CONVERT_TO_CHAR for DATETIME values
459  FUNCTION CONVERT_TO_CHAR_(P_EXPR IN TS	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR
460  IS
461  V_FORMAT VARCHAR2(100);
462  V_RESULT VARCHAR2(4000);
463  BEGIN
464    IF P_STYLE IS NOT NULL THEN
465      V_FORMAT := GET_FORMAT_FROM_STYLE(P_STYLE);
466      v_result := TO_CHAR(P_EXPR,V_FORMAT);  
467    ELSE
468      v_result := TO_CHAR(P_EXPR);
469    END IF;
470    RETURN SUBSTR_(v_result,P_PRECISION);
471  END;
472  ---
473  FUNCTION CONVERT_TO_CHAR	(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR
474  IS BEGIN
475       RETURN SUBSTR_(P_EXPR,P_PRECISION);
476  END;
477  
478  FUNCTION CONVERT_TO_CHAR	(P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT NULL  , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR
479  IS BEGIN
480    RETURN  SUBSTR_(P_EXPR,P_PRECISION);
481  END;
482  
483  FUNCTION CONVERT_TO_CHAR	(P_EXPR IN DATE		                  , P_PRECISION IN NUMBER DEFAULT NULL   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR
484  IS
485     v_format VARCHAR2(50);
486     v_result CHAR(4000);
487  BEGIN
488     RETURN CONVERT_TO_CHAR_(P_EXPR,P_PRECISION,P_SCALE,P_STYLE);
489  END;
490  
491  FUNCTION CONVERT_TO_CHAR	(P_EXPR IN TS		            , P_PRECISION IN NUMBER DEFAULT NULL   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR
492  IS
493     v_format VARCHAR2(50);
494  BEGIN
495     RETURN CONVERT_TO_CHAR_(P_EXPR,P_PRECISION,P_SCALE,P_STYLE);
496  END;
497  
498  FUNCTION CONVERT_TO_CHAR	(P_EXPR IN TSTZ	, P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR
499  IS BEGIN
500     RETURN CONVERT_TO_CHAR(CAST(P_EXPR AS TS),P_PRECISION,P_SCALE,P_STYLE); --REMOVE TZ
501  END;
502  
503  FUNCTION CONVERT_TO_NVARCHAR2	(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN NVARCHAR2
504  IS
505  BEGIN
506     RETURN UTL_RAW.CAST_TO_NVARCHAR2(UTL_RAW.CAST_TO_RAW(CONVERT_TO_VARCHAR2(P_EXPR, P_PRECISION, P_SCALE, P_STYLE))); 
507  END;
508  
509  FUNCTION CONVERT_TO_NVARCHAR2	(P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN NVARCHAR2
510  IS
511  BEGIN
512     RETURN UTL_RAW.CAST_TO_NVARCHAR2(UTL_RAW.CAST_TO_RAW(CONVERT_TO_VARCHAR2(P_EXPR, P_PRECISION, P_SCALE, P_STYLE))); 
513  END;
514  
515  FUNCTION CONVERT_TO_NVARCHAR2	(P_EXPR IN DATE		                  , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN NVARCHAR2
516  IS
517  BEGIN
518     RETURN UTL_RAW.CAST_TO_NVARCHAR2(UTL_RAW.CAST_TO_RAW(CONVERT_TO_VARCHAR2(P_EXPR, P_PRECISION, P_SCALE, P_STYLE)));
519  END;   
520  
521  FUNCTION CONVERT_TO_NVARCHAR2	(P_EXPR IN TS		            , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN NVARCHAR2
522  IS
523  BEGIN
524    RETURN UTL_RAW.CAST_TO_NVARCHAR2(UTL_RAW.CAST_TO_RAW(CONVERT_TO_VARCHAR2(P_EXPR, P_PRECISION, P_SCALE, P_STYLE)));
525  END;
526  
527  FUNCTION CONVERT_TO_NVARCHAR2	(P_EXPR IN TSTZ	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN NVARCHAR2
528  IS BEGIN
529     RETURN CONVERT_TO_NVARCHAR2(CAST(P_EXPR AS TS),P_PRECISION,P_SCALE,P_STYLE); --REMOVE TZ
530  END;
531  
532  --- MASTER CONVERT_TO_CLOB for DATETIME values
533  FUNCTION CONVERT_TO_CLOB_(P_EXPR IN TS	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB
534  IS
535  V_FORMAT VARCHAR2(100);
536  V_RESULT VARCHAR2(4000);
537  BEGIN
538    IF P_STYLE IS NOT NULL THEN
539      V_FORMAT := GET_FORMAT_FROM_STYLE(P_STYLE);
540      v_result := TO_CHAR(P_EXPR,V_FORMAT);  
541    ELSE
542      v_result := TO_CHAR(P_EXPR);
543    END IF;
544  
545    RETURN SUBSTR_(v_result,P_PRECISION);
546  END;
547  
548  FUNCTION CONVERT_TO_CLOB	(P_EXPR IN TSTZ	, P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB
549  IS BEGIN
550     RETURN CONVERT_TO_CLOB(CAST(P_EXPR AS TS),P_PRECISION,P_SCALE,P_STYLE); --REMOVE TZ
551  END;
552  
553  ---
554  FUNCTION CONVERT_TO_CLOB	(P_EXPR IN CLOB	                , P_PRECISION IN NUMBER DEFAULT 4000, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB
555  IS BEGIN
556       RETURN SUBSTR_(P_EXPR,P_PRECISION);
557  END;
558  
559  FUNCTION CONVERT_TO_CLOB	(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT 4000, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB
560  IS BEGIN
561       RETURN SUBSTR_(P_EXPR,P_PRECISION);
562  END;
563  
564  FUNCTION CONVERT_TO_CLOB	(P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT 4000 , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB
565  IS BEGIN
566    RETURN  SUBSTR_(P_EXPR,P_PRECISION);
567  END;
568  
569  FUNCTION CONVERT_TO_CLOB	(P_EXPR IN DATE		                  , P_PRECISION IN NUMBER DEFAULT NULL   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB
570  IS
571     v_format VARCHAR2(50);
572     v_result CHAR(4000);
573  BEGIN
574     RETURN CONVERT_TO_CLOB_(P_EXPR,P_PRECISION,P_SCALE,P_STYLE);
575  END;
576  
577  FUNCTION CONVERT_TO_CLOB	(P_EXPR IN TS		            , P_PRECISION IN NUMBER DEFAULT NULL   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB
578  IS
579     v_format VARCHAR2(50);
580  BEGIN
581     RETURN CONVERT_TO_CLOB_(P_EXPR,P_PRECISION,P_SCALE,P_STYLE);
582  END;
583  
584  
585  -- commented out for now as it returns null
586  --FUNCTION CONVERT_TO_CHAR(P_EXPR IN BLOB, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT 0) RETURN CHAR
587  --IS
588  --BEGIN
589  --     RETURN SUBSTR_(CONVERT_TO_VARCHAR2(P_EXPR, P_PRECISION, P_SCALE, P_STYLE), P_PRECISION);
590  --END;
591  
592  FUNCTION datename_(p_part_expr IN VARCHAR2, p_date_expr IN TS)
593  RETURN VARCHAR2
594  IS
595    v_part VARCHAR2(15);
596    v_timestamp TS := p_date_expr;
597    v_wkday VARCHAR2(10);
598    v_year VARCHAR2(4);
599    v_temp VARCHAR2(30);
600  BEGIN
601        v_part := UPPER(p_part_expr);
602        IF v_part IN ('YEAR', 'YY', 'YYYY') THEN RETURN TO_CHAR(v_timestamp, 'YYYY');
603        ELSIF v_part IN ('QUARTER', 'QQ', 'Q') THEN RETURN TO_CHAR(v_timestamp, 'Q');
604        ELSIF v_part IN ('MONTH', 'MM', 'M') THEN RETURN TO_CHAR(v_timestamp, 'Month');
605        ElSIF v_part IN ('DAYOFYEAR', 'DY', 'Y') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'DDD'));
606        ELSIF v_part IN ('DAY', 'DD', 'D') THEN RETURN TO_CHAR(v_timestamp, 'DD');
607        ELSIF v_part IN ('WEEKDAY', 'DW', 'W') THEN RETURN TO_CHAR(v_timestamp, 'Day');
608        ElSIF v_part IN ('WEEK', 'WK', 'WW') THEN
609           -- commented out this code for now needs to be reviewed if the
610           -- result is not consistent with sybase function call datename(wk,getdate())
611           -- Oracle returns 1 short when compared to Sybase so adding 1 to the result.
612           /*
613           v_year := TO_CHAR(v_timestamp, 'YYYY');
614           v_wkday := TO_CHAR(TO_DATE('01-01-'|| v_year, 'MM-DD-YYYY'), 'DAY');
615           IF v_wkday = TO_CHAR(v_timestamp, 'DAY') THEN
616              RETURN TO_CHAR(v_timestamp, 'WW');
617           ELSE
618              RETURN TO_CHAR(v_timestamp, 'WW') + 1;
619           END IF;
620           */
621           RETURN TO_CHAR(v_timestamp, 'WW');
622        ElSIF v_part IN ('HOUR', 'HH') THEN RETURN TO_CHAR(v_timestamp, 'fmHH24');
623        ElSIF v_part IN ('MINUTE', 'MI', 'N') THEN RETURN TO_CHAR(v_timestamp, 'fmMI');
624        ElSIF v_part IN ('SECOND', 'SS', 'S') THEN RETURN TO_CHAR(v_timestamp, 'fmSS');
625        ElSIF v_part IN ('MILLISECOND', 'MS', 'FF3') THEN 
626            v_temp := TO_CHAR(v_timestamp, 'FF3');
627            IF v_temp = '000' THEN
628               RETURN '0';
629            ELSE   
630               RETURN v_temp;
631            END IF;   
632        ElSIF v_part IN ('MICROSECOND', 'MCS', 'FF6') THEN 
633            v_temp := TO_CHAR(v_timestamp, 'FF6');
634            IF v_temp = '000000' THEN
635               RETURN '0';
636            ELSE   
637               RETURN v_temp;
638            END IF;
639        ElSIF v_part IN ('NANOSECOND', 'NS', 'FF9') THEN 
640            v_temp := TO_CHAR(v_timestamp, 'FF9');
641            IF v_temp = '000000000' THEN
642               RETURN '0';
643            ELSE   
644               RETURN v_temp;
645            END IF;
646        ElSIF v_part IN ('TZOFFSET', 'TZ') THEN RETURN TO_CHAR(v_timestamp, 'TZH') || ':' || TO_CHAR(v_timestamp, 'TZM');
647        ELSE
648          RETURN NULL;
649        END IF;
650  
651  EXCEPTION
652      WHEN OTHERS THEN
653        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);  
654  END datename_;
655  
656  FUNCTION datename(p_part_expr IN VARCHAR2, p_date_str IN VARCHAR2) 
657  RETURN VARCHAR2
658  IS
659      v_part VARCHAR2(15);
660      v_date DATE;
661      v_ts TS;
662      v_wkday VARCHAR2(10);
663      v_year VARCHAR2(4);
664  BEGIN
665        v_ts := CONVERT_STRING_TO_TIMESTAMP(TRIM(p_date_str));   
666        RETURN datename_(p_part_expr, v_TS);
667  EXCEPTION
668      WHEN OTHERS THEN
669        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);  
670  END datename;
671  
672  FUNCTION datename(p_part_expr IN VARCHAR2, p_date_expr IN DATE) 
673  RETURN VARCHAR2
674  IS
675  BEGIN
676      RETURN datename_(p_part_expr, p_date_expr);
677  EXCEPTION
678      WHEN OTHERS THEN
679        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK); 
680  END datename;
681  
682  FUNCTION datename(p_part_expr IN VARCHAR2, p_date_expr IN TS) 
683  RETURN VARCHAR2
684  IS
685  BEGIN
686     RETURN datename_(p_part_expr, p_date_expr);
687  EXCEPTION
688      WHEN OTHERS THEN
689        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK); 
690  END datename;
691  
692  FUNCTION DATENAME(P_PART_EXPR IN VARCHAR2, P_DATE_EXPR IN TSTZ)  RETURN VARCHAR2
693  IS BEGIN
694     RETURN DATENAME(P_PART_EXPR , CAST(P_DATE_EXPR AS TS)); --REMOVE TZ
695  END;
696  
697  
698  FUNCTION datepart_(p_part_expr IN VARCHAR2, p_date_expr IN TS)
699  RETURN NUMBER
700  IS
701    v_part VARCHAR2(15) := p_part_expr;
702    v_timestamp TS := p_date_expr;
703    v_wkday VARCHAR2(10);
704    v_year VARCHAR2(4);
705  BEGIN
706        v_part := UPPER(p_part_expr);
707        IF v_part IN ('YEAR', 'YY', 'YYYY') THEN  RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'YYYY'));
708        ELSIF v_part IN ('QUARTER', 'QQ', 'Q')  THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'Q'));
709        ELSIF v_part IN ('MONTH', 'MM', 'M') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'MM'));
710        ElSIF v_part IN ('DAYOFYEAR', 'DY', 'Y') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'DDD'));
711        ELSIF v_part IN ('DAY', 'DD', 'D') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'DD'));
712        ELSIF v_part IN ('WEEKDAY', 'DW', 'W') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'D'));
713        -- Oracle returns 1 short when compared to Sybase so adding 1 to the result.
714        ElSIF v_part IN ('WEEK', 'WK', 'WW') THEN  
715           v_year := TO_CHAR(v_timestamp, 'YYYY');
716           FOR i in DT_FORMATS.FIRST .. DT_FORMATS.LAST
717           LOOP
718              BEGIN
719                v_wkday := TO_CHAR(TO_DATE('01-01-'|| v_year, DT_FORMATS(i)), 'DAY');
720                EXIT;
721              EXCEPTION
722               WHEN OTHERS THEN
723                  NULL; 
724              END;
725           END LOOP;
726           IF v_wkday = TO_CHAR(v_timestamp, 'DAY') THEN
727              RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'WW'));
728           ELSE
729              RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'WW')) + 1;
730           END IF; 
731        ElSIF v_part IN ('HOUR', 'HH') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'HH24'));
732        ElSIF v_part IN ('MINUTE', 'MI', 'N') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'MI'));
733        ElSIF v_part IN ('SECOND', 'SS', 'S') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'SS'));
734        ElSIF v_part IN ('MILLISECOND', 'MS', 'FF3') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'FF3'));
735        ElSIF v_part IN ('MICROSECOND', 'MCS', 'US', 'FF6') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'FF6'));
736        ElSIF v_part IN ('NANOSECOND', 'NS', 'FF9') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'FF9'));
737        ElSIF v_part IN ('CALYEAROFWEEK', 'CYR', 'IYYY') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'IYYY')); 
738        ElSIF v_part IN ('CALWEEKOFYEAR', 'CWK', 'IW') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'IW'));
739        -- Oracle returns 1 more when compared to Sybase so subtract 1 to the result.
740        ElSIF v_part IN ('CALDAYOFWEEK', 'CDW', 'D') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'D')) - 1;
741        ELSE
742          RETURN NULL;
743        END IF;
744  EXCEPTION
745      WHEN OTHERS THEN
746        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
747  END datepart_;
748  
749  FUNCTION datepart(p_part_expr IN VARCHAR2, p_date_str IN VARCHAR2)
750  RETURN NUMBER
751  IS
752     v_ts TS;
753  BEGIN  
754        v_ts := CONVERT_STRING_TO_TIMESTAMP(p_date_str);
755        RETURN datepart_(p_part_expr, v_ts);
756  EXCEPTION
757      WHEN OTHERS THEN
758        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
759  END datepart;
760  
761  FUNCTION datepart(p_part_expr IN VARCHAR2, p_date_expr IN TS)
762  RETURN NUMBER
763  IS
764  BEGIN
765      RETURN datepart_(p_part_expr, p_date_expr);
766  EXCEPTION
767      WHEN OTHERS THEN
768        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
769  END datepart;
770  
771  FUNCTION DATEPART(P_PART_EXPR IN VARCHAR2, P_DATE_EXPR IN TSTZ) RETURN NUMBER
772  IS BEGIN
773     RETURN DATEPART(P_PART_EXPR , CAST(P_DATE_EXPR AS TS)); --REMOVE TZ
774  END;
775  
776  FUNCTION datepart(p_part_expr IN VARCHAR2, p_date_expr IN DATE)
777  RETURN NUMBER
778  IS
779  BEGIN
780      RETURN datepart_(p_part_expr, p_date_expr);
781  EXCEPTION
782      WHEN OTHERS THEN
783        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
784  END datepart;
785  
786  
787  FUNCTION dateadd_(p_interval IN VARCHAR2,  p_interval_val IN NUMBER, p_date_exp IN TS)
788  RETURN TS
789  IS
790    v_ucase_interval VARCHAR2(10);
791    v_date TS;
792    v_datestr VARCHAR2(30);
793    v_result TS;
794  BEGIN
795      v_date := p_date_exp;
796      v_ucase_interval := UPPER(p_interval);    
797      IF v_ucase_interval IN ('YEAR', 'YY', 'YYYY') 
798      THEN
799        RETURN ADD_MONTHS(v_date, p_interval_val * 12);
800      ELSIF v_ucase_interval IN ('QUARTER', 'QQ', 'Q') 
801      THEN
802        IF LAST_DAY(v_date) = v_date THEN
803           v_datestr := EXTRACT(MONTH FROM v_date) + (p_interval_val * 3);
804           v_datestr := v_datestr || '-' || EXTRACT(DAY FROM v_date) || '-' || EXTRACT(YEAR FROM v_date);
805           v_datestr := v_datestr || ' ' || TO_CHAR(v_date, 'HH12') || ':' || TO_CHAR(v_date, 'MI') || ':' || TO_CHAR(v_date, 'SS');
806           v_datestr := v_datestr || '.' || TO_CHAR(v_date, 'FF3 AM') ;
807           v_result := TO_TIMESTAMP(v_datestr, 'MM-DD-YYYY HH12:MI:SS.FF3 AM');
808           RETURN v_result;
809        ELSE
810           RETURN ADD_MONTHS(v_date, p_interval_val * 3);
811        END IF;   
812      ELSIF v_ucase_interval IN ('MONTH', 'MM', 'M') 
813      THEN
814        BEGIN
815           v_result := v_date + NUMTOYMINTERVAL(p_interval_val, 'MONTH') + NUMTODSINTERVAL(0, 'HOUR');
816        EXCEPTION WHEN OTHERS THEN
817         --problem due to resulting date not being able to handle a particular day like (Ex: Feb 31)
818         v_result := ADD_MONTHS(v_date, p_interval_val) ; -- this will use the last valid day (Ex: Feb 28)
819        END;
820        RETURN v_result;
821      ElSIF v_ucase_interval IN ('DAYOFYEAR', 'DY', 'Y', 'DAY', 'DD', 'D', 'WEEKDAY', 'DW', 'W') 
822      THEN
823        RETURN v_date + NUMTODSINTERVAL(p_interval_val, 'DAY');
824      ElSIF v_ucase_interval IN ('WEEK', 'WK', 'WW') 
825      THEN
826        RETURN v_date + (p_interval_val * 7);
827      ElSIF v_ucase_interval IN ('HOUR', 'HH') 
828      THEN
829        -- RETURN v_date + (p_interval_val / 24);
830         RETURN v_date + NUMTODSINTERVAL(p_interval_val, 'HOUR');
831      ElSIF v_ucase_interval IN ('MINUTE', 'MI', 'N') 
832      THEN
833        -- RETURN v_date + NUMTODSINTERVAL((p_interval_val / 24 / 60), 'MINUTE');
834        RETURN v_date + NUMTODSINTERVAL(p_interval_val, 'MINUTE');
835      ElSIF v_ucase_interval IN ('SECOND', 'SS', 'S') 
836      THEN
837        -- RETURN v_date + (p_interval_val / 24 / 60 / 60);
838        RETURN v_date + NUMTODSINTERVAL(p_interval_val, 'SECOND');
839      ElSIF v_ucase_interval IN ('MILLISECOND', 'MS') 
840      THEN
841        -- result accurate to one three-hundredth of a second 
842        RETURN v_date + NUMTODSINTERVAL(3.33 * ROUND(p_interval_val/3.33), 'SECOND')/1000;
843      ELSE
844        RETURN NULL;
845      END IF;
846  EXCEPTION
847      WHEN OTHERS THEN
848        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK); 
849  END dateadd_;
850  
851  FUNCTION dateadd(p_interval IN VARCHAR2, p_interval_val IN NUMBER, p_date_str IN VARCHAR2)
852  RETURN TS
853  IS
854      v_ts TS;
855  BEGIN
856      v_ts := CONVERT_STRING_TO_TIMESTAMP(p_date_str);
857      RETURN dateadd_(p_interval, p_interval_val, v_ts);
858  EXCEPTION
859      WHEN OTHERS THEN
860        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
861  END dateadd;
862  
863  FUNCTION dateadd(p_interval IN VARCHAR2, p_interval_val IN NUMBER, p_date_expr IN DATE)
864  RETURN DATE
865  IS
866  BEGIN
867      RETURN CAST(dateadd_(p_interval, p_interval_val, p_date_expr) AS DATE);
868  EXCEPTION
869      WHEN OTHERS THEN
870        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
871  END dateadd;
872  
873  FUNCTION dateadd(p_interval IN VARCHAR2, p_interval_val IN NUMBER, p_date_expr IN TS)
874  RETURN TS
875  IS  
876  BEGIN
877      RETURN dateadd_(p_interval, p_interval_val, p_date_expr);
878  EXCEPTION
879      WHEN OTHERS THEN
880        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
881  END dateadd;
882  
883  FUNCTION DATEADD(P_INTERVAL IN VARCHAR2, P_INTERVAL_VAL IN NUMBER, P_DATE_EXPR IN TSTZ) RETURN TS
884  IS BEGIN
885     RETURN DATEADD(P_INTERVAL ,P_INTERVAL_VAL, CAST(P_DATE_EXPR AS TS)); --REMOVE TZ
886  END;
887  
888  FUNCTION degrees(p_angle_radians IN NUMBER) 
889  RETURN NUMBER
890  IS
891  BEGIN
892      IF p_angle_radians IS NULL THEN
893        RETURN NULL;
894      END IF;
895  
896      RETURN ROUND(p_angle_radians / pi() * 180);
897  EXCEPTION 
898      WHEN OTHERS THEN
899        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
900  END degrees;
901  
902  --SQLSERVER
903  FUNCTION year_(p_date_str IN VARCHAR2)
904  RETURN NUMBER
905  IS
906      v_date DATE;
907  BEGIN
908      v_date := CONVERT_STRING_TO_TIMESTAMP(p_date_str);
909      IF v_date IS NULL THEN
910        RETURN NULL;
911      END IF;
912      RETURN TO_NUMBER(TO_CHAR(v_date, 'YYYY'));
913  EXCEPTION
914      WHEN OTHERS THEN
915        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
916  END year_;
917  
918  FUNCTION year_(p_date_expr IN DATE) 
919  RETURN NUMBER
920  IS
921  BEGIN
922     RETURN EXTRACT(YEAR FROM p_date_expr);
923  EXCEPTION
924      WHEN OTHERS THEN
925        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
926  END year_;
927  
928  FUNCTION year_(p_date_expr IN TS)
929  RETURN NUMBER
930  IS
931  BEGIN
932     RETURN EXTRACT(YEAR FROM p_date_expr);
933  EXCEPTION
934      WHEN OTHERS THEN
935        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
936  END year_;
937  
938  FUNCTION YEAR_(P_DATE_EXPR   IN TSTZ) RETURN NUMBER
939  IS BEGIN
940     RETURN YEAR_(CAST(P_DATE_EXPR AS TS)); --REMOVE TZ
941  END;
942  
943  FUNCTION difference(p_expr1 IN VARCHAR2, p_expr2 IN VARCHAR2)
944  RETURN NUMBER
945  IS
946      sound_ex_val_1 CHAR(4);
947      sound_ex_val_2 CHAR(4);
948      similarity NUMBER := 0;
949      idx NUMBER := 1; 
950  BEGIN
951      IF p_expr1 IS NULL OR p_expr2 IS NULL THEN
952         RETURN NULL;
953      END IF; 
954      sound_ex_val_1 := SOUNDEX(p_expr1);
955      sound_ex_val_2 := SOUNDEX(p_expr2); 
956      LOOP
957         IF SUBSTR(sound_ex_val_1, idx, 1) = SUBSTR(sound_ex_val_2, idx, 1) THEN
958            similarity := similarity + 1;
959         END IF;
960  
961         idx := idx + 1;   
962         EXIT WHEN idx > 4;
963      END LOOP;
964      RETURN similarity;
965  EXCEPTION
966      WHEN OTHERS THEN
967         raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
968  END difference;
969  
970  FUNCTION datediff_sqlserver(p_datepart IN VARCHAR2, p_start_date_expr IN TS, p_end_date_expr IN TS)
971  RETURN NUMBER
972  IS
973      v_ret_value NUMBER := NULL;
974      v_part VARCHAR2(15);
975      v_start_ts  TS;
976      v_end_ts  TS;
977      v_start_date  DATE;
978      v_end_date  DATE;
979  BEGIN
980      v_part := p_datepart;
981      v_start_ts := p_start_date_expr;
982      v_end_ts := p_end_date_expr;
983      v_start_date := TO_DATE(EXTRACT(YEAR FROM v_start_ts) || '-' || EXTRACT(MONTH FROM v_start_ts) || '-' || EXTRACT(DAY FROM v_start_ts), 'YYYY-MM-DD');
984      v_end_date := TO_DATE(EXTRACT(YEAR FROM v_end_ts) || '-' || EXTRACT(MONTH FROM v_end_ts) || '-' || EXTRACT(DAY FROM v_end_ts), 'YYYY-MM-DD');
985      v_part := UPPER(p_datepart);
986  
987      IF v_part IN ('YEAR', 'YY', 'YYYY') THEN
988        v_ret_value :=EXTRACT(YEAR FROM v_end_ts) - EXTRACT(YEAR FROM v_start_ts) ;
989      ELSIF v_part IN ('QUARTER', 'QQ', 'Q') THEN
990         v_ret_value := ROUND(MONTHS_BETWEEN(v_end_ts, v_start_ts) / 3);
991      ELSIF v_part IN ('MONTH', 'MM', 'M') THEN
992         v_ret_value := ROUND(MONTHS_BETWEEN(TRUNC(v_end_ts, 'MM'), TRUNC(v_start_ts, 'MM')));
993       ElSIF v_part IN ('DAYOFYEAR', 'DY', 'Y') THEN
994         v_ret_value := ROUND(CAST(v_end_ts AS DATE) - CAST(v_start_ts AS DATE));
995      ElSIF v_part IN ('DAY', 'DD', 'D') THEN
996         v_ret_value := ROUND(v_end_date - v_start_date);
997      ElSIF v_part IN ('WEEK', 'WK', 'WW') THEN
998         v_ret_value := ROUND((CAST(v_end_ts AS DATE) - CAST(v_start_ts AS DATE)) / 7);
999      ELSIF v_part IN ('WEEKDAY', 'DW', 'W') THEN
1000         -- v_ret_value := TO_CHAR(v_end_ts, 'D') - TO_CHAR(v_start_ts, 'D');
1001         -- In Sybase the result is similar to using date part 'Week 'or 'wk' in datediff function
1002         IF EXTRACT(YEAR FROM v_end_ts) = EXTRACT(YEAR FROM v_start_ts) THEN
1003            v_ret_value := EXTRACT(DAY FROM v_end_ts) - EXTRACT(DAY FROM v_start_ts);
1004         ELSE
1005            v_ret_value := ROUND((TRUNC(v_end_ts, 'DD') - TRUNC(v_start_ts, 'DD')) / 7);
1006         END IF;
1007      ElSIF v_part IN ('HOUR', 'HH') THEN
1008         v_ret_value := ROUND(v_end_date - v_start_date) * 24;
1009         v_ret_value := ROUND(v_ret_value + ((EXTRACT(HOUR FROM v_end_ts) - EXTRACT(HOUR FROM v_start_ts))));
1010      ElSIF v_part IN ('MINUTE', 'MI', 'N') THEN
1011         v_ret_value := ROUND(v_end_date - v_start_date) * 24 * 60;
1012         v_ret_value := v_ret_value + ((EXTRACT(HOUR FROM v_end_ts) - EXTRACT(HOUR FROM v_start_ts)) * 60);
1013         v_ret_value := ROUND(v_ret_value + ((EXTRACT(MINUTE FROM v_end_ts) - EXTRACT(MINUTE FROM v_start_ts))));
1014      ElSIF v_part IN ('SECOND', 'SS', 'S') THEN
1015         v_ret_value := ROUND(v_end_date - v_start_date) * 24 * 60 * 60;
1016         v_ret_value := v_ret_value + ((EXTRACT(HOUR FROM v_end_ts) - EXTRACT(HOUR FROM v_start_ts)) * 60 * 60);
1017         v_ret_value := v_ret_value + ((EXTRACT(MINUTE FROM v_end_ts) - EXTRACT(MINUTE FROM v_start_ts)) * 60);
1018         v_ret_value := ROUND(v_ret_value + ((EXTRACT(SECOND FROM v_end_ts) - EXTRACT(SECOND FROM v_start_ts))));
1019      ElSIF v_part IN ('MILLISECOND', 'MS') THEN
1020         v_ret_value := ROUND(v_end_date - v_start_date) * 24 * 60 * 60 * 1000;
1021         v_ret_value := v_ret_value + ((EXTRACT(HOUR FROM v_end_ts) - EXTRACT(HOUR FROM v_start_ts)) * 60 * 60 * 1000);
1022         v_ret_value := v_ret_value + ((EXTRACT(MINUTE FROM v_end_ts) - EXTRACT(MINUTE FROM v_start_ts)) * 60 * 1000);
1023         v_ret_value := ROUND(v_ret_value + ((EXTRACT(SECOND FROM v_end_ts) - EXTRACT(SECOND FROM v_start_ts)) * 1000));
1024      ElSIF v_part IN ('MICROSECOND', 'MCS') THEN
1025         v_ret_value := ROUND(v_end_date - v_start_date) * 24 * 60 * 60 * 1000000;
1026         v_ret_value := v_ret_value + ((EXTRACT(HOUR FROM v_end_ts) - EXTRACT(HOUR FROM v_start_ts)) * 60 * 60 * 1000000);
1027         v_ret_value := v_ret_value + ((EXTRACT(MINUTE FROM v_end_ts) - EXTRACT(MINUTE FROM v_start_ts)) * 60 * 1000000);
1028         v_ret_value := ROUND(v_ret_value + ((EXTRACT(SECOND FROM v_end_ts) - EXTRACT(SECOND FROM v_start_ts)) * 1000000));
1029      ElSIF v_part IN ('NANOSECOND', 'NS') THEN
1030         v_ret_value := ROUND(v_end_date - v_start_date) * 24 * 60 * 60 * 1000000000;
1031         v_ret_value := v_ret_value + ((EXTRACT(HOUR FROM v_end_ts) - EXTRACT(HOUR FROM v_start_ts)) * 60 * 60 * 1000000000);
1032         v_ret_value := v_ret_value + ((EXTRACT(MINUTE FROM v_end_ts) - EXTRACT(MINUTE FROM v_start_ts)) * 60 * 1000000000);
1033         v_ret_value := ROUND(v_ret_value + ((EXTRACT(SECOND FROM v_end_ts) - EXTRACT(SECOND FROM v_start_ts)) * 1000000000));
1034      END IF;
1035      RETURN v_ret_value;
1036  EXCEPTION
1037       WHEN OTHERS THEN
1038        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1039  END datediff_sqlserver;
1040  
1041  --http://st-doc.us.oracle.com/database/121/SQLRF/functions066.htm#SQLRF00639
1042  --TIMESTAMP-TIMESTAMP = INTERVAL DAY TO SECOND
1043  FUNCTION datediff_sybase(p_datepart IN VARCHAR2, p_start_date_expr IN TS, p_end_date_expr IN TS)
1044  RETURN NUMBER
1045  IS
1046      v_ret_value NUMBER := NULL;
1047      v_diff INTERVAL DAY(9) TO SECOND(9);
1048      v_years NUMBER;
1049      v_weeks NUMBER;
1050      v_days NUMBER;
1051      v_hours NUMBER;
1052      v_minutes NUMBER;
1053      v_seconds NUMBER;
1054      v_milliseconds NUMBER;
1055      v_microseconds NUMBER;
1056  BEGIN
1057      v_diff := p_end_date_expr -  p_start_date_expr;
1058      --TIMESTAMP - TIMESTAMP  = INTERVAL DAY TO SECOND
1059      v_days := EXTRACT(DAY FROM v_diff);
1060      v_hours := EXTRACT(HOUR FROM v_diff);
1061      v_minutes :=EXTRACT(MINUTE FROM v_diff);
1062      v_seconds :=EXTRACT(SECOND FROM v_diff);
1063      --MILLISECONDS: In Sybase only 1 second precision is taken into account
1064      v_milliseconds := v_seconds - TRUNC(v_seconds);--full milliseconds (0.123456)
1065      v_milliseconds := ROUND(v_milliseconds*10)*100;--only 1 precision of milliseconds (100);
1066      v_microseconds := v_seconds - TRUNC(v_seconds);--full microseconds(0.123456)
1067      v_microseconds := TRUNC(v_microseconds * 1000000);
1068  
1069      IF p_datepart IN ('WEEK', 'WK', 'WW') THEN
1070             v_ret_value :=  (NEXT_DAY(TRUNC(p_end_date_expr),'Sunday') -  NEXT_DAY(TRUNC(p_start_date_expr),'Sunday'))/7 ;
1071      ELSIF p_datepart IN ('DAY', 'DD', 'D','DAYOFYEAR', 'DY', 'Y') THEN
1072          --CANT USER THE INTERVAL DIFF(v_difF), AS EVEN 2 SECONDS COULD SEPERATE A DAY (1 second before midnight, 1 second after midnight
1073          --INSTEAD FIRST REMOVE HOURS/MINS FROM INITIAL VALUES THEN FIND THE INTERVAL
1074           v_ret_value :=  TRUNC(p_end_date_expr) -  TRUNC(p_start_date_expr);
1075      ElSIF p_datepart IN ('HOUR', 'HH') THEN
1076            v_ret_value := (v_days*24)+v_hours;
1077      ElSIF p_datepart IN ('MINUTE', 'MI', 'N') THEN
1078            v_ret_value :=(v_days*24*60)+(v_hours*60)+v_minutes;
1079      ElSIF p_datepart IN ('SECOND', 'SS', 'S') THEN
1080          --SECONDS CAN HAVE MILLISECONDS AS WELL, SO NEED TO TRUNCATE THESE IN SYBASE
1081            v_ret_value := (v_days*24*60*60)+(v_hours*60*60)+(v_minutes*60)+TRUNC(v_seconds);
1082      ElSIF p_datepart IN ('MILLISECOND', 'MS') THEN
1083            v_ret_value := (v_days*24*60*60*1000)+(v_hours*60*60*1000)+(v_minutes*60*1000)+(TRUNC(v_seconds)*1000)+v_milliseconds;
1084      ElSIF p_datepart IN ('MICROSECOND', 'MCS') THEN 
1085            v_ret_value := (v_days*24*60*60*1000000)+(v_hours*60*60*1000000)+(v_minutes*60*1000000)+(TRUNC(v_seconds)*1000000)+v_microseconds;
1086      ElSIF p_datepart IN ('NANOSECOND', 'NS') THEN
1087          --NANOSECONDS: In Sybase only 1 second precision is taken into account
1088            v_ret_value := (v_days*24*60*60*1000000)+(v_hours*60*60*1000000)+(v_minutes*60*1000000)+(TRUNC(v_seconds)*1000000000)+(v_microseconds*100);
1089      ELSIF p_datepart IN ('QUARTER', 'QQ', 'Q') THEN
1090         v_ret_value :=   (TO_CHAR(p_end_date_expr,'YYYY')*4 +
1091                           TO_CHAR(p_end_date_expr,'Q'))
1092                          -
1093                          (TO_CHAR(p_start_date_expr,'YYYY')*4  +
1094                           TO_CHAR(p_start_date_expr,'Q'));
1095      ELSIF p_datepart IN ('WEEKDAY', 'DW', 'W') THEN --WEEKDAY IN SYBASE RETURNS THE NUMBER OF WEEKS!
1096        v_ret_value :=  TRUNC((TRUNC(p_end_date_expr) -  TRUNC(p_start_date_expr))/7);
1097      ELSE   
1098            v_ret_value := datediff_sqlserver(p_datepart,p_start_date_expr,p_end_date_expr);
1099      END IF;
1100      RETURN v_ret_value;
1101  EXCEPTION
1102       WHEN OTHERS THEN
1103        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1104  END datediff_sybase;
1105  
1106  FUNCTION datediff_(p_datepart IN VARCHAR2, p_start_date_expr IN TS, p_end_date_expr IN TS)
1107  RETURN NUMBER
1108  AS BEGIN
1109   IF DATABASE_TYPE = SYBASE THEN
1110      RETURN datediff_sybase(UPPER(p_datepart),p_start_date_expr,p_end_date_expr);
1111   ELSE
1112      RETURN datediff_sqlserver(p_datepart,p_start_date_expr,p_end_date_expr);
1113   END IF;
1114  END datediff_;
1115  
1116  FUNCTION NUMBERTODATE (P_NUM NUMBER) RETURN DATE
1117  IS BEGIN
1118    RETURN ZERODATETIME()+P_NUM;
1119  END;
1120  
1121  FUNCTION datediff(p_datepart IN VARCHAR2, p_start_date_str IN VARCHAR2, p_end_date_str IN VARCHAR2)
1122  RETURN NUMBER
1123  IS
1124      v_start_ts  TS;
1125      v_end_ts  TS;
1126  BEGIN
1127    v_start_ts := CONVERT_STRING_TO_TIMESTAMP(TRIM(p_start_date_str));
1128    v_end_ts := CONVERT_STRING_TO_TIMESTAMP(TRIM(p_end_date_str));
1129     RETURN datediff_(p_datepart, v_start_ts, v_end_ts);
1130  EXCEPTION
1131       WHEN OTHERS THEN
1132        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1133  END datediff;
1134  
1135  FUNCTION datediff(p_datepart IN VARCHAR2, p_start_date_expr IN DATE, p_end_date_expr IN DATE)
1136  RETURN NUMBER
1137  IS
1138  BEGIN
1139        RETURN datediff_(p_datepart, p_start_date_expr, p_end_date_expr);
1140  EXCEPTION
1141       WHEN OTHERS THEN
1142        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1143  END datediff;
1144  
1145  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN DATE, P_END_DATE_EXPR IN NUMBER) RETURN NUMBER
1146  IS BEGIN
1147    RETURN DATEDIFF(P_DATEPART,P_START_DATE_EXPR,NUMBERTODATE(P_END_DATE_EXPR));
1148  END;
1149  
1150  FUNCTION datediff(p_datepart IN VARCHAR2, p_start_date_expr IN TS, p_end_date_expr IN TS)
1151  RETURN NUMBER
1152  IS
1153  BEGIN
1154       RETURN datediff_(p_datepart, p_start_date_expr, p_end_date_expr);
1155  EXCEPTION
1156       WHEN OTHERS THEN
1157        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1158  END datediff;
1159  
1160  
1161  FUNCTION datediff(P_DATEPART IN VARCHAR2, P_START_DATE_STR IN VARCHAR2, P_END_DATE_EXPR IN DATE) RETURN NUMBER
1162  IS
1163  BEGIN
1164       RETURN datediff_(p_datepart,  CONVERT_STRING_TO_TIMESTAMP(TRIM(p_start_date_str)), p_end_date_expr);
1165  EXCEPTION
1166       WHEN OTHERS THEN
1167        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1168  END DATEDIFF;
1169  
1170  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_STR IN VARCHAR2, P_END_DATE_EXPR IN NUMBER) RETURN NUMBER
1171  IS BEGIN
1172    RETURN DATEDIFF(P_DATEPART,P_START_DATE_STR,NUMBERTODATE(P_END_DATE_EXPR));
1173  END;
1174  
1175  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_STR IN VARCHAR2, P_END_DATE_EXPR IN TS) RETURN NUMBER
1176  IS
1177  BEGIN
1178       RETURN datediff_(p_datepart,  CONVERT_STRING_TO_TIMESTAMP(TRIM(p_start_date_str)), p_end_date_expr);
1179  EXCEPTION
1180       WHEN OTHERS THEN
1181        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1182  END DATEDIFF;
1183  
1184  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_STR IN VARCHAR2, P_END_DATE_EXPR IN TSTZ) RETURN NUMBER
1185  IS BEGIN
1186     RETURN DATEDIFF(P_DATEPART,P_START_DATE_STR , CAST(P_END_DATE_EXPR AS TS)); --REMOVE TZ
1187  END;
1188  
1189  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN DATE, P_END_DATE_STR IN VARCHAR2) RETURN NUMBER
1190  IS
1191  BEGIN
1192       RETURN datediff_(p_datepart, p_start_date_expr,  CONVERT_STRING_TO_TIMESTAMP(TRIM(p_end_date_str)));
1193  EXCEPTION
1194       WHEN OTHERS THEN
1195        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1196  END DATEDIFF;
1197  
1198  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN DATE, P_END_DATE_EXPR IN TS) RETURN NUMBER
1199  IS
1200  BEGIN
1201       RETURN datediff_(p_datepart, p_start_date_expr, p_end_date_expr);
1202  EXCEPTION
1203       WHEN OTHERS THEN
1204        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1205  END DATEDIFF;
1206  
1207  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN DATE, P_END_DATE_EXPR IN TSTZ) RETURN NUMBER
1208  IS
1209  BEGIN
1210       RETURN datediff(p_datepart, p_start_date_expr, CAST(p_end_date_expr AS TS));
1211  END DATEDIFF;
1212  
1213  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN NUMBER, P_END_DATE_EXPR IN DATE) RETURN NUMBER
1214  IS BEGIN
1215    RETURN DATEDIFF(P_DATEPART,NUMBERTODATE(P_START_DATE_EXPR),P_END_DATE_EXPR);
1216  END;
1217  
1218  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN NUMBER, P_END_DATE_EXPR IN NUMBER) RETURN NUMBER
1219  IS BEGIN
1220  RETURN DATEDIFF(P_DATEPART,NUMBERTODATE(P_START_DATE_EXPR),NUMBERTODATE(P_END_DATE_EXPR));
1221  END;
1222  
1223  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN NUMBER, P_END_DATE_STR IN VARCHAR2) RETURN NUMBER
1224  IS BEGIN
1225    RETURN DATEDIFF(P_DATEPART,NUMBERTODATE(P_START_DATE_EXPR),P_END_DATE_STR);
1226  END;
1227  
1228  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN NUMBER, P_END_DATE_EXPR IN TS) RETURN NUMBER
1229  IS BEGIN
1230    RETURN DATEDIFF(P_DATEPART,NUMBERTODATE(P_START_DATE_EXPR),P_END_DATE_EXPR);
1231  END;
1232  
1233  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN NUMBER, P_END_DATE_EXPR IN TSTZ) RETURN NUMBER
1234  IS BEGIN
1235    RETURN DATEDIFF(P_DATEPART,NUMBERTODATE(P_START_DATE_EXPR),P_END_DATE_EXPR);
1236  END;
1237  
1238  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TS, P_END_DATE_EXPR IN DATE) RETURN NUMBER
1239  IS
1240  BEGIN
1241       RETURN datediff_(p_datepart, p_start_date_expr, p_end_date_expr);
1242  EXCEPTION
1243       WHEN OTHERS THEN
1244        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1245  END DATEDIFF;
1246  
1247  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TS, P_END_DATE_EXPR IN NUMBER) RETURN NUMBER
1248  IS BEGIN
1249   RETURN DATEDIFF(P_DATEPART,P_START_DATE_EXPR,NUMBERTODATE(P_END_DATE_EXPR));
1250  END;
1251  
1252  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TS, P_END_DATE_STR IN VARCHAR2) RETURN NUMBER
1253  IS
1254  BEGIN
1255       RETURN datediff_(p_datepart, p_start_date_expr,  CONVERT_STRING_TO_TIMESTAMP(TRIM(p_end_date_str)));
1256  EXCEPTION
1257       WHEN OTHERS THEN
1258        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1259  END DATEDIFF;
1260  
1261  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TS, P_END_DATE_EXPR IN TSTZ) RETURN NUMBER
1262  IS BEGIN
1263       RETURN datediff(p_datepart, p_start_date_expr,  CAST(P_END_DATE_EXPR AS TS));--REMOVE TZ
1264  END DATEDIFF;
1265  
1266  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TSTZ, P_END_DATE_EXPR IN TSTZ) RETURN NUMBER
1267  IS BEGIN
1268  RETURN DATEDIFF(P_DATEPART,CAST(P_START_DATE_EXPR AS TS),P_END_DATE_EXPR);--REMOVE TZ
1269  END DATEDIFF;
1270  
1271  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TSTZ, P_END_DATE_EXPR IN TS) RETURN NUMBER
1272  IS BEGIN
1273  RETURN DATEDIFF(P_DATEPART,CAST(P_START_DATE_EXPR AS TS),P_END_DATE_EXPR);--REMOVE TZ
1274  END DATEDIFF;
1275  
1276  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TSTZ, P_END_DATE_EXPR IN DATE) RETURN NUMBER
1277  IS BEGIN
1278  RETURN DATEDIFF(P_DATEPART,CAST(P_START_DATE_EXPR AS TS),P_END_DATE_EXPR);--REMOVE TZ
1279  END DATEDIFF;
1280  
1281  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TSTZ, P_END_DATE_EXPR IN NUMBER) RETURN NUMBER
1282  IS BEGIN
1283   RETURN DATEDIFF(P_DATEPART,P_START_DATE_EXPR,NUMBERTODATE(P_END_DATE_EXPR));
1284  END;
1285  FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TSTZ, P_END_DATE_STR IN VARCHAR2) RETURN NUMBER
1286  IS BEGIN
1287  RETURN DATEDIFF(P_DATEPART,CAST(P_START_DATE_EXPR AS TS),P_END_DATE_STR);--REMOVE TZ
1288  END DATEDIFF;
1289  
1290  FUNCTION month_(p_date_str IN VARCHAR2)
1291  RETURN NUMBER
1292  IS
1293      v_date DATE;
1294      v_dateformat VARCHAR2(50);
1295  BEGIN
1296      v_date := CONVERT_STRING_TO_TIMESTAMP(p_date_str);
1297      IF v_date IS NULL THEN
1298        RETURN NULL;
1299      END IF;
1300  
1301      RETURN TO_NUMBER(TO_CHAR(v_date, 'MM'));
1302  EXCEPTION
1303      WHEN OTHERS THEN
1304        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1305  END MONTH_;
1306  
1307  FUNCTION month_(p_date_expr IN DATE)
1308  RETURN NUMBER
1309  IS
1310  BEGIN
1311      RETURN EXTRACT(MONTH FROM p_date_expr);
1312  EXCEPTION
1313      WHEN OTHERS THEN
1314        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1315  END MONTH_;
1316  
1317  FUNCTION month_(p_date_expr IN TS)
1318  RETURN NUMBER
1319  IS
1320  BEGIN
1321      RETURN EXTRACT(MONTH FROM p_date_expr);
1322  EXCEPTION
1323      WHEN OTHERS THEN
1324        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1325  END MONTH_;
1326  
1327  FUNCTION MONTH_(P_DATE_EXPR  IN TSTZ) RETURN NUMBER
1328  IS
1329  BEGIN
1330      RETURN MONTH_(CAST(p_date_expr AS TS));
1331  END MONTH_;
1332  
1333  -- PUBLIC NOT REFACTORED YET
1334  FUNCTION rand(p_seed NUMBER DEFAULT NULL)
1335  RETURN NUMBER
1336  IS
1337      v_rand_num NUMBER;
1338  BEGIN
1339        IF p_seed IS NOT NULL THEN
1340           DBMS_RANDOM.SEED(p_seed);
1341        END IF;
1342  
1343        v_rand_num := DBMS_RANDOM.VALUE();
1344  
1345        RETURN v_rand_num;
1346  EXCEPTION
1347       WHEN OTHERS THEN
1348         raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1349  END rand;
1350  
1351  PROCEDURE resetTrancount
1352  IS
1353  BEGIN	
1354     trancount := 0;
1355  END resetTrancount;
1356  
1357  FUNCTION isnumeric(p_expr IN VARCHAR2)
1358  RETURN NUMBER
1359  IS
1360      numeric_val NUMBER;
1361      temp_str VARCHAR2(50);
1362  BEGIN
1363      temp_str := p_expr;
1364      IF SUBSTR(temp_str, 1, 1) = '$' THEN
1365         temp_str := SUBSTR(temp_str, 2);
1366      END IF;
1367  
1368      numeric_val := TO_NUMBER(temp_str);
1369      RETURN 1;
1370  EXCEPTION
1371      WHEN OTHERS THEN
1372         RETURN 0;
1373  END isnumeric;
1374  
1375  FUNCTION stats_date(p_table IN VARCHAR2, p_index IN VARCHAR2)
1376  RETURN DATE
1377  IS
1378      v_last_analyzed DATE;
1379  BEGIN
1380      SELECT last_analyzed INTO v_last_analyzed
1381        FROM USER_IND_STATISTICS
1382       WHERE table_name LIKE UPPER(p_table)
1383         AND index_name LIKE UPPER(p_index);
1384  
1385      RETURN v_last_analyzed;
1386  EXCEPTION
1387      WHEN OTHERS THEN
1388         raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1389  END stats_date;
1390  
1391  FUNCTION oct(p_num VARCHAR2)
1392  RETURN VARCHAR2
1393  IS
1394  BEGIN
1395      RETURN to_base(p_num, 8);
1396  EXCEPTION
1397      WHEN OTHERS THEN
1398        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1399  END oct;
1400  
1401  FUNCTION quotename(p_str IN VARCHAR2, p_delimiters IN VARCHAR2 DEFAULT '[]')
1402  RETURN VARCHAR2
1403  IS
1404      v_ret_val VARCHAR2(150) := NULL;
1405  BEGIN
1406      IF p_delimiters = '[]' THEN
1407         v_ret_val := '[' || REPLACE(p_str, ']', ']]') || ']';
1408      ELSIF p_delimiters = '"' THEN
1409         v_ret_val := '"' || p_str || '"';
1410      ELSIF p_delimiters = '''' THEN
1411         v_ret_val := '''' || p_str || '''';
1412        END IF;
1413  
1414        RETURN v_ret_val;
1415  EXCEPTION
1416        WHEN OTHERS THEN
1417           raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1418  END quotename;
1419  
1420  FUNCTION parsename(p_object_name IN VARCHAR2, p_object_piece IN NUMBER)
1421  RETURN VARCHAR2
1422  IS
1423      ret_val VARCHAR2(150) := NULL;
1424      pos NUMBER;
1425      v_next_pos NUMBER;
1426  BEGIN
1427      IF p_object_name IS NULL THEN 
1428         RETURN NULL;
1429      END IF;
1430  
1431      -- for 10g
1432      IF NOT DBMS_DB_VERSION.VER_LE_9_2 THEN
1433        IF p_object_piece = 1 THEN -- object name
1434           ret_val := REGEXP_SUBSTR(p_object_name, '(^[^\.]+$)|(\.[^\.]+$)');
1435           ret_val := REPLACE(ret_val, '.', '');
1436        ELSIF p_object_piece = 2 THEN -- schema name
1437           ret_val := REGEXP_SUBSTR(p_object_name, '([^\.]+)\.([^\.]+$)');
1438           ret_val := REGEXP_REPLACE(ret_val, '\.([^\.]+$)', '');
1439        ELSIF p_object_piece = 3 THEN -- database name
1440           ret_val := REGEXP_SUBSTR(p_object_name, '([^\.]+)\.([^\.]*)\.([^\.]+$)');
1441           ret_val := REGEXP_REPLACE(ret_val, '\.([^\.]*)\.([^\.]+$)', '');
1442        ELSIF p_object_piece = 4 THEN -- server name
1443           ret_val := REGEXP_SUBSTR(p_object_name, '^([^\.]+)\.([^\.]*)\.([^\.]*)\.([^\.]+$)');
1444           IF ret_val IS NOT NULL THEN
1445             ret_val := REGEXP_REPLACE(p_object_name, '^([^\.]+)\.([^\.]*)\.([^\.]*)\.([^\.]+$)', '\1');
1446           END IF;
1447        END IF;
1448      ELSE
1449        ret_val := p_object_name;
1450        v_next_pos := LENGTH(p_object_name);
1451        FOR i IN 1 .. p_object_piece LOOP
1452          pos := INSTR(p_object_name, '.', -1, i);
1453          IF pos > 0 THEN
1454            ret_val := SUBSTR(p_object_name, pos + 1, v_next_pos - pos);
1455          END IF;
1456          v_next_pos := pos;
1457        END LOOP;
1458  
1459        IF LENGTH(ret_val) = 0 THEN
1460          RETURN NULL;
1461        END IF;
1462      END IF;
1463  
1464      RETURN ret_val;
1465  EXCEPTION
1466      WHEN OTHERS THEN
1467         raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1468  END PARSENAME;
1469  
1470  FUNCTION fetch_status(p_cursorfound IN BOOLEAN)
1471  RETURN NUMBER
1472  IS
1473       v_fetch_status NUMBER := 0;
1474  BEGIN
1475     CASE
1476       WHEN p_cursorfound THEN
1477          v_fetch_status := 0; --fetch successful
1478       ELSE
1479          v_fetch_status := -1; --fetch unsuccessful
1480       END CASE;
1481       RETURN v_fetch_status;
1482  EXCEPTION
1483      WHEN OTHERS THEN
1484         raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1485  END fetch_status;
1486  
1487  FUNCTION sqlstatus(p_cursorfound IN BOOLEAN,p_cursoropen IN BOOLEAN)
1488  RETURN NUMBER
1489  IS
1490       v_sqlerror NUMBER := 0;
1491  BEGIN
1492     CASE
1493       WHEN NOT p_cursoropen THEN
1494          v_sqlerror := 1; -- fetch statement resulted in an error
1495       WHEN p_cursorfound THEN
1496          v_sqlerror := 0; --successful completion
1497       ELSE 
1498   		v_sqlerror :=2;  --no more data in result set
1499       END CASE;
1500       RETURN v_sqlerror;
1501  EXCEPTION
1502      WHEN OTHERS THEN
1503         raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1504  END sqlstatus;
1505  
1506  FUNCTION ident_seed(p_sequence IN VARCHAR2)
1507  RETURN NUMBER
1508  IS
1509      v_seed NUMBER;
1510  BEGIN
1511        SELECT min_value INTO v_seed
1512           FROM USER_SEQUENCES
1513           WHERE sequence_name LIKE UPPER(p_sequence);
1514  
1515        RETURN v_seed;
1516  EXCEPTION
1517      WHEN OTHERS THEN
1518         raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1519  END IDENT_SEED;
1520  
1521  FUNCTION to_base(p_dec NUMBER, p_base NUMBER) 
1522  RETURN VARCHAR2
1523  IS
1524      v_str VARCHAR2(255);
1525      v_num NUMBER;
1526      v_hex VARCHAR2(16) DEFAULT '0123456789ABCDEF';
1527  BEGIN
1528      v_num := p_dec;
1529  
1530      IF p_dec IS NULL OR p_base IS NULL THEN
1531        RETURN NULL;
1532      END IF;
1533  
1534      IF TRUNC(p_dec) <> p_dec OR p_dec < 0 THEN
1535          RAISE PROGRAM_ERROR;
1536      END IF;
1537  
1538      LOOP
1539        v_str := SUBSTR(v_hex, MOD(v_num, p_base) + 1, 1) || v_str;
1540        v_num := TRUNC(v_num / p_base);
1541  
1542        EXIT WHEN v_num = 0;
1543      END LOOP;
1544  
1545      RETURN v_str;
1546  EXCEPTION
1547      WHEN OTHERS THEN
1548        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1549  END TO_BASE;
1550  
1551  FUNCTION TO_SECOND(P_TIME VARCHAR2) 
1552  RETURN NUMBER
1553  IS
1554    v_hours NUMBER;
1555    v_minutes NUMBER;
1556    v_seconds NUMBER;
1557    v_tot_seconds NUMBER;
1558  BEGIN
1559    v_hours := REGEXP_REPLACE(P_TIME, '((\d{1,2})\:(\d{2})\:(\d{2}))', '\2');
1560    v_minutes := REGEXP_REPLACE(P_TIME, '((\d{1,2})\:(\d{2})\:(\d{2}))', '\3');
1561    v_seconds := REGEXP_REPLACE(P_TIME, '((\d{1,2})\:(\d{2})\:(\d{2}))', '\4');
1562    v_tot_seconds := v_hours * 60 * 60 + v_minutes * 60 + v_seconds;
1563    RETURN v_tot_seconds;
1564  EXCEPTION
1565      WHEN OTHERS THEN
1566        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1567  END TO_SECOND;
1568  
1569  PROCEDURE decrementTrancount
1570  IS
1571  BEGIN	
1572  	IF trancount > 0 THEN
1573        	trancount := trancount - 1;
1574     	END IF;
1575  END decrementTrancount;
1576  
1577  FUNCTION hex(p_num VARCHAR2)
1578  RETURN VARCHAR2
1579  IS
1580  BEGIN
1581      RETURN to_base(p_num, 16);
1582    EXCEPTION
1583      WHEN OTHERS THEN
1584        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1585  END hex;
1586  
1587  FUNCTION isdate(p_expr IN VARCHAR2)
1588  RETURN NUMBER
1589  IS
1590       v_is_valid_date BINARY_INTEGER := 0;
1591  BEGIN
1592      IF CONVERT_STRING_TO_TIMESTAMP(p_expr) IS NOT NULL THEN
1593         RETURN 1;
1594      ELSE 
1595         SELECT NVL2(TO_DATE(p_expr), 1, 0) INTO v_is_valid_date FROM DUAL;
1596         RETURN v_is_valid_date;
1597      END IF;    
1598  EXCEPTION 
1599      WHEN OTHERS THEN
1600         RETURN 0;
1601  END isdate;
1602  
1603  FUNCTION radians(p_degree IN NUMBER)
1604  RETURN NUMBER
1605  IS
1606      v_rad NUMBER;
1607  BEGIN
1608      v_rad := p_degree / 180 * pi();
1609  
1610      IF INSTR(TO_CHAR(p_degree),'.') = 0 THEN
1611          v_rad := FLOOR(v_rad);
1612      ELSE 
1613          v_rad := round(p_degree / 180 * pi(),18); 
1614      END IF;
1615  
1616      RETURN v_Rad ;
1617  EXCEPTION
1618      WHEN OTHERS THEN
1619        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1620  END radians;
1621  
1622  FUNCTION GETIDENTITY RETURN NUMBER
1623  IS
1624  BEGIN
1625   RETURN IDENTITY_VALUE;
1626  END;
1627  
1628  FUNCTION ident_incr(p_sequence IN VARCHAR2)
1629  RETURN NUMBER
1630  IS
1631      v_incr_by NUMBER;
1632  BEGIN
1633      SELECT increment_by INTO v_incr_by
1634         FROM USER_SEQUENCES
1635         WHERE sequence_name LIKE UPPER(p_sequence);
1636  
1637      RETURN v_incr_by;
1638  EXCEPTION
1639      WHEN OTHERS THEN
1640         raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1641  END ident_incr;
1642  
1643  FUNCTION day_(p_date_str IN VARCHAR2)
1644  RETURN NUMBER
1645  IS
1646      v_date DATE;
1647  BEGIN
1648      v_date := CONVERT_STRING_TO_TIMESTAMP(p_date_str);
1649      IF v_date IS NULL THEN
1650        RETURN NULL;
1651      END IF;
1652  
1653      RETURN TO_NUMBER(TO_CHAR(v_date, 'DD'));
1654  EXCEPTION
1655      WHEN OTHERS THEN
1656        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1657  END day_;
1658  
1659  FUNCTION day_(p_date_expr IN DATE)
1660  RETURN NUMBER
1661  IS
1662  BEGIN
1663      RETURN EXTRACT(DAY FROM p_date_expr);
1664  EXCEPTION
1665      WHEN OTHERS THEN
1666        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1667  END day_;
1668  
1669  FUNCTION day_(p_date_expr IN TS)
1670  RETURN NUMBER
1671  IS
1672  BEGIN
1673      RETURN EXTRACT(DAY FROM p_date_expr);
1674  EXCEPTION
1675      WHEN OTHERS THEN
1676        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1677  END day_;
1678  
1679  FUNCTION DAY_(P_DATE_EXPR    IN TSTZ) RETURN NUMBER
1680  IS
1681  BEGIN
1682      RETURN DAY_(CAST(p_date_expr AS TS));
1683  END DAY_;
1684  
1685  FUNCTION stuff(p_expr VARCHAR2, p_startIdx NUMBER, p_len NUMBER, p_replace_expr VARCHAR2) 
1686  RETURN VARCHAR2
1687  IS
1688  BEGIN
1689         RETURN REPLACE(p_expr, SUBSTR(p_expr, p_startIdx, p_len), p_replace_expr);
1690  EXCEPTION
1691          WHEN OTHERS THEN
1692            raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1693  END stuff;
1694  PROCEDURE commit_transaction
1695  IS
1696  BEGIN	
1697     IF trancount <= 1 THEN
1698          COMMIT;
1699     END IF;
1700     resetTrancount;
1701  END commit_transaction;
1702  
1703  --RETURN A NUMBER TO HELP REPLICATE @@TRANSTATE
1704  FUNCTION  COMMIT_TRANSACTION_STATE RETURN NUMBER
1705  IS
1706  BEGIN	
1707     IF trancount <= 1 THEN
1708          COMMIT;
1709     END IF;
1710     resetTrancount;
1711     RETURN 1;
1712  EXCEPTION WHEN OTHERS THEN
1713    RETURN 3;   
1714  END COMMIT_TRANSACTION_STATE;
1715  
1716  FUNCTION round_(p_expr NUMBER, p_len NUMBER, p_function NUMBER DEFAULT 0) 
1717  RETURN NUMBER
1718  IS
1719      v_ret_value NUMBER;
1720  BEGIN
1721        IF p_function = 0 THEN
1722           v_ret_value := ROUND(p_expr, p_len);
1723        ELSE
1724           v_ret_value := TRUNC(p_expr, p_len);
1725        END IF;
1726  
1727        RETURN v_ret_value;
1728  EXCEPTION
1729       WHEN OTHERS THEN
1730         raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1731  END round_;
1732  
1733  FUNCTION patindex(p_pattern IN VARCHAR2, p_expr IN VARCHAR2, p_format IN VARCHAR2)
1734  RETURN NUMBER
1735  IS
1736      v_search_pattern VARCHAR2(100);
1737      v_pos NUMBER := 0;
1738      v_charsfmt VARCHAR2(20) := 'using chars';
1739      v_charactersfmt  VARCHAR2(20) := 'using characters';
1740      v_bytesfmt VARCHAR2(20) := 'using bytes';
1741      v_format VARCHAR2(20);
1742      v_errmsg VARCHAR2(50) := 'Invalid format: ';
1743  BEGIN
1744        IF p_pattern IS NULL OR p_expr IS NULL THEN
1745           RETURN NULL;
1746        END IF;
1747  
1748        IF NOT DBMS_DB_VERSION.VER_LE_9_2 THEN
1749          v_search_pattern := p_pattern;
1750          v_search_pattern := REPLACE(v_search_pattern, '\', '\\');
1751          v_search_pattern := REPLACE(v_search_pattern, '*', '\*');
1752          v_search_pattern := REPLACE(v_search_pattern, '+', '\+');
1753          v_search_pattern := REPLACE(v_search_pattern, '?', '\?');
1754          v_search_pattern := REPLACE(v_search_pattern, '|', '\|');
1755          v_search_pattern := REPLACE(v_search_pattern, '^', '\^');
1756          v_search_pattern := REPLACE(v_search_pattern, '$', '\$');
1757          v_search_pattern := REPLACE(v_search_pattern, '.', '\.');
1758          v_search_pattern := REPLACE(v_search_pattern, '{', '\{');
1759          v_search_pattern := REPLACE(v_search_pattern, '_', '.');
1760  
1761          v_format := lower(p_format);
1762          IF v_format = v_charsfmt OR v_format = v_charactersfmt THEN
1763             IF SUBSTR(v_search_pattern, 1, 1) != '%' AND 
1764                SUBSTR(v_search_pattern, -1, 1) != '%' THEN
1765                 v_search_pattern := '^' || v_search_pattern || '$';
1766             ELSIF SUBSTR(v_search_pattern, 1, 1) != '%' THEN
1767                 v_search_pattern := '^' || SUBSTR(v_search_pattern, 1, LENGTH(v_search_pattern) - 1);
1768             ELSIF SUBSTR(v_search_pattern, -1, 1) != '%' THEN
1769                 v_search_pattern := SUBSTR(v_search_pattern, 2) || '$';
1770             ELSE
1771                 v_search_pattern := SUBSTR(v_search_pattern, 2, LENGTH(v_search_pattern) - 2);
1772             END IF;    
1773          ELSIF v_format = v_bytesfmt THEN    
1774             IF SUBSTRB(v_search_pattern, 1, 1) != '%' AND 
1775                SUBSTRB(v_search_pattern, -1, 1) != '%' THEN
1776                 v_search_pattern := '^' || v_search_pattern || '$';
1777             ELSIF SUBSTRB(v_search_pattern, 1, 1) != '%' THEN
1778                 v_search_pattern := '^' || SUBSTRB(v_search_pattern, 1, LENGTHB(v_search_pattern) - 1);
1779             ELSIF SUBSTRB(v_search_pattern, -1, 1) != '%' THEN
1780                 v_search_pattern := SUBSTRB(v_search_pattern, 2) || '$';
1781             ELSE
1782                 v_search_pattern := SUBSTRB(v_search_pattern, 2, LENGTHB(v_search_pattern) - 2);
1783             END IF;    
1784          ELSE
1785              v_errmsg := v_errmsg || p_format;
1786              raise_application_error(-20001, v_errmsg);
1787          END IF;
1788          v_pos := REGEXP_INSTR(p_expr, v_search_pattern);
1789        ELSE 
1790          v_pos := 0;
1791        END IF;
1792  
1793        RETURN v_pos;
1794  EXCEPTION
1795      WHEN OTHERS THEN
1796        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1797  END patindex;
1798  PROCEDURE incrementTrancount
1799  IS
1800  BEGIN	
1801     trancount := trancount + 1;
1802  END INCREMENTTRANCOUNT;
1803  
1804  FUNCTION reverse_(p_expr IN VARCHAR2)
1805  RETURN VARCHAR2
1806  IS
1807      v_result VARCHAR2(2000) := NULL;
1808  BEGIN      
1809      FOR i IN 1..LENGTH(p_expr) LOOP
1810        v_result := v_result || SUBSTR(p_expr, -i, 1);
1811      END LOOP;
1812  
1813      RETURN v_result;    
1814  EXCEPTION 
1815      WHEN OTHERS THEN
1816        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1817  END reverse_;
1818  
1819  PROCEDURE SET_DATABASE_TYPE (P_DATABASE_TYPE IN VARCHAR2)
1820  AS
1821  BEGIN
1822  DATABASE_TYPE := P_DATABASE_TYPE;
1823  END SET_DATABASE_TYPE;
1824  
1825  FUNCTION SPID  RETURN NUMBER
1826  AS 
1827  BEGIN
1828  RETURN USERENV('sessionid');
1829  END;
1830  
1831  FUNCTION STR(P_EXPR IN NUMBER, P_LEN IN NUMBER DEFAULT 10, P_SCALE IN NUMBER DEFAULT 0)  RETURN VARCHAR2
1832  IS
1833      v_ret_val VARCHAR2(50);
1834      v_temp_val NUMBER;
1835      v_format_str VARCHAR2(50);
1836      v_len NUMBER;
1837      v_val NUMBER;
1838      v_has_decimal BOOLEAN := FALSE;
1839  BEGIN
1840        IF INSTR(TO_CHAR(p_expr), '.') > 0 THEN
1841          v_has_decimal := TRUE;
1842          v_len := LENGTH(SUBSTR(TO_CHAR(p_expr), 1, INSTR(TO_CHAR(p_expr), '.')-1));
1843        ELSE
1844          v_len := LENGTH(TO_CHAR(p_expr));
1845        END IF;  
1846  
1847        IF p_len < v_len THEN
1848           RETURN TRIM(LPAD(' ', p_len+1,'*'));
1849        END IF;
1850  
1851        v_temp_val := p_expr;
1852        IF p_len >= v_len THEN
1853           v_temp_val := ROUND(v_temp_val, p_scale);
1854        ELSE
1855           v_temp_val := ROUND(v_temp_val, 0);
1856        END IF;   
1857  
1858        IF p_scale > 0 AND v_has_decimal THEN
1859           IF v_len >= (p_len - p_scale) THEN
1860               v_format_str := LPAD(' ', v_len+1, '9');
1861           ELSE    
1862               v_format_str := LPAD(' ', (p_len - p_scale), '9');
1863           END IF;
1864           v_format_str := TRIM(v_format_str);
1865           IF INSTR(TO_CHAR(p_expr), '.') != p_len THEN 
1866             v_format_str := v_format_str || '.';
1867             v_format_str := RPAD(v_format_str, p_len, '9');
1868           END IF;  
1869        ELSE
1870           v_format_str := TRIM(LPAD(' ', p_len+1, '9'));
1871        END IF;
1872        v_ret_val := TO_CHAR(v_temp_val, v_format_str);
1873        RETURN v_ret_val;
1874  EXCEPTION 
1875        WHEN OTHERS THEN
1876          raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
1877  END STR;
1878  
1879  PROCEDURE IDENTITY_RESET( V_IDENTITYID VARCHAR2) AS
1880  BEGIN
1881  identitymap(v_identityid) := 0;
1882  END;
1883  
1884  FUNCTION IDENTITY( V_IDENTITYID VARCHAR2, V_SEED  INT DEFAULT 1, V_INCREMENT  INT DEFAULT 1) RETURN NUMBER
1885  as
1886    v_current number(20) := 0;
1887  begin
1888    dbms_output.put_line('v_current1:'||v_current);
1889    begin
1890    v_current := identitymap(v_identityid);
1891    exception when others then
1892     v_current := 0;
1893    END;
1894    dbms_output.put_line('v_current2:'||v_Current);
1895    if v_current = 0 then
1896      identitymap(v_identityID):= 0;
1897    end if;
1898    v_current := identitymap(v_identityid);
1899    v_current := v_current + 1;
1900    identitymap(v_identityid) := v_current;
1901    return v_current;
1902  end;
1903  
1904  FUNCTION OBJECT_ID(objectref VARCHAR2) RETURN INT
1905  AS
1906    ownerName  VARCHAR2(128);
1907    objectName VARCHAR2(128);
1908    objectId   INT;
1909  BEGIN
1910    --select * from all_objects;
1911    --select object_id('system.redo_log') from dual;
1912    IF( INSTR(objectref,'.') = 0 )THEN
1913      ownerName             := NULL;
1914      objectName            := objectref;
1915    ELSE
1916      ownerName  := SUBSTR(objectref,0,INSTR(objectref,'.')-1);
1917      objectName := SUBSTR(objectref,INSTR(objectref,'.')  +1);
1918    END IF;
1919    BEGIN
1920      SELECT object_id
1921      INTO objectId
1922      FROM all_objects
1923      WHERE UPPER(owner)     = UPPER(NVL(ownerName,owner))
1924      AND  UPPER(object_name) = UPPER(objectName) ;
1925    EXCEPTION WHEN OTHERS THEN objectId := NULL;
1926    END;
1927    RETURN objectId;
1928  END;
1929  
1930  PROCEDURE RAISERROR(ERRORCODE NUMBER,MSG VARCHAR2)
1931  AS
1932  BEGIN
1933      -- NOTE: Oracle raise_application_error will terminate normal code flow , which T-SQL raiserror does not.
1934  	-- raise_application_error(ERRORCODE||':'||MSG);
1935  	DBMS_OUTPUT.PUT_LINE(ERRORCODE||':'||MSG);
1936  END;
1937  
1938  PROCEDURE HANDLEERROR(ERRORCODE NUMBER,MSG VARCHAR2)
1939  AS
1940  BEGIN
1941      -- NOTE: Oracle raise_application_error will terminate normal code flow , which T-SQL raiserror does not.
1942      raise_application_error(-20002,ERRORCODE||':'||MSG);
1943  	--DBMS_OUTPUT.PUT_LINE(ERRORCODE||':'||MSG);
1944  END;
1945  
1946  FUNCTION error_line RETURN VARCHAR2
1947  AS
1948  BEGIN
1949   RETURN '0';
1950  END;
1951  
1952  FUNCTION error_procedure RETURN VARCHAR2
1953  AS
1954  BEGIN
1955   RETURN '0';
1956  END;
1957  
1958  FUNCTION error_severity RETURN VARCHAR2
1959  AS
1960  BEGIN
1961   RETURN '0';
1962  END;
1963  
1964  FUNCTION error_state RETURN VARCHAR2
1965  AS
1966  BEGIN
1967   RETURN '0';
1968  END;
1969  
1970  BEGIN
1971  
1972  -- Datetime formats/styles starting with DAY only --
1973  DT_DAY := VARCHAR2_ARRAY(
1974  ----------- SQLServer and Sybase Datetime formats/styles --------------
1975  ----- Format/Style ------       ------ Standard ------ 
1976  'fxfmdd/mm/yy',                    --British/French
1977  'fxfmdd/mm/yyyy',                  --British/French(with Century)
1978  'fxfmdd.mm.yy',                    --German(without Century)
1979  'fxfmdd.mm.yyyy',                  --German(with Century)
1980  'fxfmdd-mm-yy',                    --Italian(without Century)
1981  'fxfmdd-mm-yyyy',                  --Italian(with Century)
1982  'fxfmdd mon yy',                   --(without Century)
1983  'fxfmdd mon yyyy',                 --(with Century)
1984  'dd mon yyyy hh24:mi:ssxff3',      --Europe default+milliseconds
1985  'fxdd mon yyyy hh12:mi:ss:ff3AM',  --Hijri calendar system 
1986  'fxdd/mm/yy hh12:mi:ss:ff3AM',     --Hijri calendar system 
1987  
1988  -------- Some more DateTime formats that were addressed before --------
1989  'fmdd yyyy MONTH',
1990  
1991  ----------------- Additional DateTime formats ------------------------- 
1992  'fmdd Month',
1993  'fmdd Month yy',
1994  'fmdd Month yyyy',
1995  'fxddmmyy',
1996  'fxddmmyyyy',
1997  'fxdd-Mon-yy',
1998  'fxdd-MON-yy',
1999  'fxdd-Mon-yyyy',
2000  'fxdd-MON-yyyy'
2001  );
2002  
2003  -- Datetime formats/styles starting with MONTH only --
2004  DT_MONTH := VARCHAR2_ARRAY(
2005  ----------- SQLServer and Sybase Datetime formats/styles --------------
2006  ----- Format/Style ------       ------ Standard ------ 
2007  'fxfmmm/dd/yyyy hh24:mi:ss',       --SQLSERVER 101  
2008  'fmmon dd yyyy hh:miAM',           --Default   
2009  'fxfmmm/dd/yy',                    --US(without Century)
2010  'fxfmmm/dd/yyyy',                  --US(with Century)
2011  'fxfmMon dd, yy',                  --(without Century)
2012  'fxfmMon dd, yyyy',                --(with Century)
2013  'mon dd yyyy hh12:mi:ssxff3am',    --Default+milliseconds
2014  'fxfmmm-dd-yy',                    --US(without Century)
2015  'fxfmmm-dd-yyyy',                  --US(with Century)
2016  
2017  -------- Some more DateTime formats that were addressed before -------- 
2018  'fmMONTH, yyyy',
2019  'MON yyyy',
2020  'fmMONTH dd, yyyy',
2021  ----------------- Additional DateTime formats ------------------------- 
2022  'mm/yy',
2023  'mm/yyyy',
2024  'fmMonth dd, yyyy',             
2025  'fmMonth dd',
2026  'mm-yy',
2027  'mm-yyyy',
2028  'fxmmddyy',
2029  'fxmmddyyyy',
2030  'Mon-yy',
2031  'Mon-yyyy',
2032  'MON-yy',
2033  'MON-yyyy'
2034  );
2035  
2036  -- Datetime formats/styles starting with YEAR only --
2037  DT_YEAR := VARCHAR2_ARRAY(
2038  ----------- SQLServer and Sybase Datetime formats/styles --------------
2039  ----- Format/Style ------       ------ Standard ------ 
2040  'fxfmyy.mm.dd',                    --ANSI(without Century)
2041  'fxfmyyyy.mm.dd',                  --ANSI(with Century)
2042  'fxfmyy/mm/dd',                    --Japan(without Century)
2043  'fxfmyyyy/mm/dd',                  --Japan(with Century)
2044  'yymmdd',                          --ISO(without Century)
2045  'yyyymmdd',                        --ISO(with Century)
2046  'fxyyyy-mm-dd hh24:mi:ss',         --ODBC canonical
2047  'fxyyyy-mm-dd hh24:mi:ssxff3',     --ODBC canonical (with milliseconds)
2048  'fxyyyy-mm-dd"T"hh12:mi:ssxff3',   --ISO8601 (no spaces)
2049  'fxyyyy-mm-dd hh12:mi:ssxff3',     --ISO8601 (with space)
2050  
2051  -------- Some more DateTime formats that were addressed before -------- 
2052  'fxyyyymmdd hh24:mi:ss',
2053  'fxyyyy-mm-dd',                    --ISO8601 Date only
2054  'fxyyyy-mm-dd hh12:mi:ss',
2055  'yyyy MON',
2056  
2057  ----------------- Additional DateTime formats ------------------------- 
2058  'yy/mm',
2059  'yyyy/mm',
2060  'yy-mm',
2061  'yyyy-mm'
2062  );
2063  
2064  -- TIME formats/styles --
2065  DT_TIME := VARCHAR2_ARRAY(
2066  ----------- SQLServer and Sybase Datetime formats/styles --------------
2067  ----- Format/Style ------       ------ Standard ------ 
2068  'hh:mi:ss',
2069  'hh24:mi:ssxff3',
2070  
2071  -------- Some more Time formats that were addressed before ------------ 
2072  'hh12 AM',                         --Time using Hour
2073  'hh12:mi:ss AM'                    --Time
2074  );
2075  
2076  -- ORACLE Server NLS DATETIME FORMATS --
2077  DT_NLS := VARCHAR2_ARRAY(
2078  getNLSDATEformat,
2079  getNLSTSformat,
2080  getNLSTSformat
2081  );
2082  
2083  -- TIME formats/styles --
2084  DT_TIMESTAMP := VARCHAR2_ARRAY(
2085  'fxfmmm/dd/yyyy hh24:mi:ss.ff9',
2086  'yyyy-mm-dd hh24:mi:ss.ff9'
2087  );
2088  /*
2089   You can modify the DT_FORMATS as you wish.
2090   Put the most likely Datetime Formats or 
2091   Nested Table Type variables at the top.
2092   For e.g: 
2093     DT_FORMATS := DT_MONTH MULTISET UNION DT_NLS;
2094     DT_FORMATS := DT_YEAR MULTISET UNION DT_TIME;
2095     DT_FORMATS := VARCHAR2_ARRAY('mm-dd-yy');
2096  */
2097  DT_FORMATS := DT_MONTH MULTISET UNION DT_YEAR MULTISET UNION DT_NLS MULTISET UNION DT_TIMESTAMP;
2098  
2099  END utils;
2100  /

Package Body UTILS compiled

SQL> 
SQL> GRANT ALL ON utils TO ROLE_migrationRepo;

Error starting at line : 2 340 File @ D:\univer\!МСХОАД\migrate\migrationRepo\generated\2025-02-18_10-02-17\master.sql
In command -
GRANT ALL ON utils TO ROLE_migrationRepo
Error report -
ORA-01917: пользователь или роль 'ROLE_MIGRATIONREPO' не существует

https://docs.oracle.com/error-help/db/ora-01917/01917. 00000 -  "user or role '%s' does not exist"
*Cause:    A user or role by that name did not exist.
*Action:   Re-specify the name.
SQL> grant ALL on utils to lab10 with grant option;

Error starting at line : 2 341 File @ D:\univer\!МСХОАД\migrate\migrationRepo\generated\2025-02-18_10-02-17\master.sql
In command -
grant ALL on utils to lab10 with grant option
Error report -
ORA-01917: пользователь или роль 'LAB10' не существует

https://docs.oracle.com/error-help/db/ora-01917/01917. 00000 -  "user or role '%s' does not exist"
*Cause:    A user or role by that name did not exist.
*Action:   Re-specify the name.
SQL> 
SQL> set define on
SQL> prompt connecting to lab10
connecting to lab10
SQL> alter session set current_schema=lab10;

Error starting at line : 2 345 File @ D:\univer\!МСХОАД\migrate\migrationRepo\generated\2025-02-18_10-02-17\master.sql
In command -
alter session set current_schema=lab10
Error report -
ORA-01435: такого пользователя не существует

https://docs.oracle.com/error-help/db/ora-01435/01435. 00000 -  "user does not exist"
*Cause:    This message is caused by any reference to a
           non-existent user. For example, it occurs if a SELECT, GRANT,
           or REVOKE statement specifies a username that did not exist.
           Only a GRANT CONNECT statement may specify a new username. All
           other GRANT and REVOKE statements must specify existing
           usernames. If specified in a SELECT statement, usernames must
           already exist.
*Action:   Specify only existing usernames in the SELECT, GRANT,
           or REVOKE statement or ask the database administrator to
           define the new username.
SQL> set define off
SQL> -- DROP TABLE Users CASCADE CONSTRAINTS;
SQL> 
SQL> 
SQL> PROMPT Creating Table Users ...
Creating Table Users ...
SQL> CREATE TABLE Users (
  2    UserID NUMBER(10,0) NOT NULL,
  3    FirstName NVARCHAR2(50) NOT NULL,
  4    LastName NVARCHAR2(50) NOT NULL,
  5    Email NVARCHAR2(100) NOT NULL,
  6    CreatedAt DATE
  7  );

Table USERS created.

SQL> 
SQL> 
SQL> PROMPT Creating Primary Key Constraint PK__Users__1788CCACE8B8A026 on table Users ... 
Creating Primary Key Constraint PK__Users__1788CCACE8B8A026 on table Users ...
SQL> ALTER TABLE Users
  2  ADD CONSTRAINT PK__Users__1788CCACE8B8A026 PRIMARY KEY
  3  (
  4    UserID
  5  )
  6  ENABLE
  7  ;

Table USERS altered.

SQL> PROMPT Creating Unique Constraint UQ__Users__A9D1053459303713 on table Users
Creating Unique Constraint UQ__Users__A9D1053459303713 on table Users
SQL> ALTER TABLE Users
  2  ADD CONSTRAINT UQ__Users__A9D1053459303713 UNIQUE (
  3    Email
  4  )
  5  ENABLE
  6  ;

Table USERS altered.

SQL> 
SQL> GRANT ALL ON Users TO ROLE_migrationRepo;

Error starting at line : 2 376 File @ D:\univer\!МСХОАД\migrate\migrationRepo\generated\2025-02-18_10-02-17\master.sql
In command -
GRANT ALL ON Users TO ROLE_migrationRepo
Error report -
ORA-01917: пользователь или роль 'ROLE_MIGRATIONREPO' не существует

https://docs.oracle.com/error-help/db/ora-01917/01917. 00000 -  "user or role '%s' does not exist"
*Cause:    A user or role by that name did not exist.
*Action:   Re-specify the name.
SQL> -- DROP TABLE Orders CASCADE CONSTRAINTS;
SQL> 
SQL> 
SQL> PROMPT Creating Table Orders ...
Creating Table Orders ...
SQL> CREATE TABLE Orders (
  2    OrderID NUMBER(10,0) NOT NULL,
  3    UserID NUMBER(10,0) NOT NULL,
  4    OrderDate DATE,
  5    TotalAmount NUMBER(10,2) NOT NULL
  6  );

Table ORDERS created.

SQL> 
SQL> 
SQL> PROMPT Creating Primary Key Constraint PK__Orders__C3905BAFA02D597F on table Orders ... 
Creating Primary Key Constraint PK__Orders__C3905BAFA02D597F on table Orders ...
SQL> ALTER TABLE Orders
  2  ADD CONSTRAINT PK__Orders__C3905BAFA02D597F PRIMARY KEY
  3  (
  4    OrderID
  5  )
  6  ENABLE
  7  ;

Table ORDERS altered.

SQL> 
SQL> GRANT ALL ON Orders TO ROLE_migrationRepo;

Error starting at line : 2 398 File @ D:\univer\!МСХОАД\migrate\migrationRepo\generated\2025-02-18_10-02-17\master.sql
In command -
GRANT ALL ON Orders TO ROLE_migrationRepo
Error report -
ORA-01917: пользователь или роль 'ROLE_MIGRATIONREPO' не существует

https://docs.oracle.com/error-help/db/ora-01917/01917. 00000 -  "user or role '%s' does not exist"
*Cause:    A user or role by that name did not exist.
*Action:   Re-specify the name.
SQL> create or replace SYNONYM utils for "EMULATION".utils;

Error starting at line : 2 399 File @ D:\univer\!МСХОАД\migrate\migrationRepo\generated\2025-02-18_10-02-17\master.sql
In command -
create or replace SYNONYM utils for "EMULATION".utils
Error report -
ORA-00955: имя уже задействовано для существующего объекта

https://docs.oracle.com/error-help/db/ora-00955/00955. 00000 -  "name is already used by an existing object"
*Cause:    An attempt was made to create a database object (such
           as a table, view, cluster, index, or synonym) that already
           existed. A user's database objects must have distinct names.
*Action:   Enter a unique name for the database object or modify
           or drop the existing object so it can be reused.
SQL> 
SQL> 
SQL> 
SQL> set define on
SQL> prompt connecting to lab10
connecting to lab10
SQL> alter session set current_schema=lab10;

Error starting at line : 2 405 File @ D:\univer\!МСХОАД\migrate\migrationRepo\generated\2025-02-18_10-02-17\master.sql
In command -
alter session set current_schema=lab10
Error report -
ORA-01435: такого пользователя не существует

https://docs.oracle.com/error-help/db/ora-01435/01435. 00000 -  "user does not exist"
*Cause:    This message is caused by any reference to a
           non-existent user. For example, it occurs if a SELECT, GRANT,
           or REVOKE statement specifies a username that did not exist.
           Only a GRANT CONNECT statement may specify a new username. All
           other GRANT and REVOKE statements must specify existing
           usernames. If specified in a SELECT statement, usernames must
           already exist.
*Action:   Specify only existing usernames in the SELECT, GRANT,
           or REVOKE statement or ask the database administrator to
           define the new username.
SQL> set define off
SQL> PROMPT Creating Foreign Key Constraint FK__Orders__UserID__49C3F6B7 on table Users...
Creating Foreign Key Constraint FK__Orders__UserID__49C3F6B7 on table Users...
SQL> ALTER TABLE Orders
  2  ADD CONSTRAINT FK__Orders__UserID__49C3F6B7 FOREIGN KEY
  3  (
  4    UserID
  5  )
  6  REFERENCES Users
  7  (
  8    UserID
  9  )
 10  ENABLE
 11  ;

Table ORDERS altered.

SQL> 
SQL> spool off;
SQL> 
SQL> COMMIT;

Commit complete.

